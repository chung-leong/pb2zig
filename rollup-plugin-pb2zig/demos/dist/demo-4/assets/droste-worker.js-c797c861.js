const O=Symbol("memory"),x=Symbol("slots"),ne=Symbol("zig"),Us=Symbol("parent"),wn=Symbol("enumName"),ri=Symbol("enumIndex"),Vn=Symbol("enumItems"),Ze=Symbol("errorIndex"),si=Symbol("enumItem"),ue=Symbol("getter"),le=Symbol("setter"),_s=Symbol("length"),qe=Symbol("proxy"),Ee=Symbol("compat"),js=Symbol("self"),Q=Symbol("childVivificator"),W=Symbol("pointerVisitor");function Z(e,t=!1){if(!t)switch(e){case 1:return Rn;case 2:return qn;case 4:return Un;case 8:return jn;case 16:return Pn;case 32:return xn}return e&7?e&3?e&1?zn:On:An:_n}function zn(e,t){for(let r=0,i=e.byteLength;r<i;r++)e.setInt8(r,t.getInt8(r))}function On(e,t){for(let r=0,i=e.byteLength;r<i;r+=2)e.setInt16(r,t.getInt16(r,!0),!0)}function An(e,t){for(let r=0,i=e.byteLength;r<i;r+=4)e.setInt32(r,t.getInt32(r,!0),!0)}function _n(e,t){for(let r=0,i=e.byteLength;r<i;r+=8)e.setInt32(r,t.getInt32(r,!0),!0),e.setInt32(r+4,t.getInt32(r+4,!0),!0)}function Rn(e,t){e.setInt8(0,t.getInt8(0))}function qn(e,t){e.setInt16(0,t.getInt16(0,!0),!0)}function Un(e,t){e.setInt32(0,t.getInt32(0,!0),!0)}function jn(e,t){e.setInt32(0,t.getInt32(0,!0),!0),e.setInt32(4,t.getInt32(4,!0),!0)}function Pn(e,t){e.setInt32(0,t.getInt32(0,!0),!0),e.setInt32(4,t.getInt32(4,!0),!0),e.setInt32(8,t.getInt32(8,!0),!0),e.setInt32(12,t.getInt32(12,!0),!0)}function xn(e,t){e.setInt32(0,t.getInt32(0,!0),!0),e.setInt32(4,t.getInt32(4,!0),!0),e.setInt32(8,t.getInt32(8,!0),!0),e.setInt32(12,t.getInt32(12,!0),!0),e.setInt32(16,t.getInt32(16,!0),!0),e.setInt32(20,t.getInt32(20,!0),!0),e.setInt32(24,t.getInt32(24,!0),!0),e.setInt32(28,t.getInt32(28,!0),!0)}function vn(e){switch(e){case 1:return $n;case 2:return kn;case 4:return Dn;case 8:return Bn;case 16:return Mn;case 32:return Nn;default:return e&7?e&3?e&1?In:En:Tn:Cn}}function In(e){for(let t=0,r=e.byteLength;t<r;t++)e.setInt8(t,0)}function En(e){for(let t=0,r=e.byteLength;t<r;t+=2)e.setInt16(t,0,!0)}function Tn(e){for(let t=0,r=e.byteLength;t<r;t+=4)e.setInt32(t,0,!0)}function Cn(e){for(let t=0,r=e.byteLength;t<r;t+=8)e.setInt32(t,0,!0),e.setInt32(t+4,0,!0)}function $n(e){e.setInt8(0,0)}function kn(e){e.setInt16(0,0,!0)}function Dn(e){e.setInt32(0,0,!0)}function Bn(e){e.setInt32(0,0,!0),e.setInt32(4,0,!0)}function Mn(e){e.setInt32(0,0,!0),e.setInt32(4,0,!0),e.setInt32(8,0,!0),e.setInt32(12,0,!0)}function Nn(e){e.setInt32(0,0,!0),e.setInt32(4,0,!0),e.setInt32(8,0,!0),e.setInt32(12,0,!0),e.setInt32(16,0,!0),e.setInt32(20,0,!0),e.setInt32(24,0,!0),e.setInt32(28,0,!0)}function F(){{const e=this[O],t=e[O];if(!t||e.buffer.byteLength!==0)return!1;const{memory:r,address:i,len:n}=t,c=new DataView(r.buffer,i,n);return c[O]=t,this[O]=c,!0}}function de(e){const t=L(e);throw new TypeError(`An initializer must be provided to the constructor of ${t}, even when it's undefined`)}function Si(e,t,r=null){const{type:i,byteSize:n}=e,c=L(e),p=t.byteLength,y=n>1?"s":"";if(i===C.Slice&&!r)throw new TypeError(`${c} has elements that are ${n} byte${y} in length, received ${p}`);{const l=i===C.Slice?r.length*n:n;throw new TypeError(`${c} has ${l} byte${y}, received ${p}`)}}function Ln(e){const{byteSize:t,typedArray:r}=e,i=t>1?"s":"",n=["ArrayBuffer","DataView"].map(oe);throw r&&n.push(oe(r.name)),new TypeError(`Expecting ${zi(n)} ${t} byte${i} in length`)}function Fn(e,t){const r=L(e);throw new TypeError(`Value given does not correspond to an item of enum ${r}: ${t}`)}function Kn(e,t){const r=L(e);throw new TypeError(`Enum item of the type ${r} expected, received ${t}`)}function Gn(e){const t=L(e);throw new TypeError(`Cannot create new enum item
Call ${t} without the use of "new" to obtain an enum object`)}function Wn(e){const t=L(e);throw new TypeError(`Cannot create new error
Call ${t} without the use of "new" to obtain an error object`)}function Hn(e){const t=L(e);throw new TypeError(`Error given is not a part of error set ${t}`)}function Xn(e,t){const r=L(e);throw new TypeError(`Error number does not corresponds to any error in error set ${r}: #${t}`)}function Yt(e,t,r){const i=L(e),n=[];if(Array.isArray(t))for(const p of t)n.push(oe(p));else n.push(oe(t));const c=wi(r);throw new TypeError(`${i} expects ${zi(n)} as argument, received ${c}`)}function he(e,t,r=!1){const{instance:{members:[i]},type:n,typedArray:c}=e,p=[],y=Ti(i);y?p.push(`array of ${y}s`):i.type===v.EnumerationItem?p.push("array of enum items"):p.push("array of objects"),c&&p.push(c.name),n===C.Slice&&r&&p.push("length"),Yt(e,p.join(" or "),t)}function Zt(e,t,r){const{length:i,instance:{members:[n]}}=e,c=L(e),{structure:{constructor:p}}=n,{length:y,constructor:l}=r,d=(t==null?void 0:t.length)??i,u=d>1?"s":"";let a;throw l===p?a="only a single one":l.child===p?a=`a slice/array that has ${y}`:a=`${y} initializer${y>1?"s":""}`,new TypeError(`${c} has ${d} element${u}, received ${a}`)}function Yn(e,t){const{instance:{members:r}}=e,i=L(e),n=[];for(const{name:c,isRequired:p}of r)p&&(t==null?void 0:t[c])===void 0&&n.push(c);throw new TypeError(`Missing initializers for ${i}: ${n.join(", ")}`)}function Ps(e,t){const r=L(e);throw new TypeError(`${r} does not have a property with that name: ${t}`)}function Zn(e,t){const{instance:{members:r}}=e,i=L(e),n=r.length-1,c=n>1?"s":"";throw new Error(`${i} expects ${n} argument${c}, received ${t}`)}function Jn(e,t,r){const{instance:{members:i}}=e,n=L(e),c=`args[${t}]`,p=i.length-1,y=t!==0?"..., ":"",l=t!==p-1?", ...":"",d=y+c+l,u=new r.constructor(`${n}(${d}): ${r.message}`);throw u.stack=r.stack,u}function Qn(e){throw new TypeError("Non-slice pointers can only be created with the help of the new operator")}function eo(e,t){const r=L(e),{constructor:{name:i}}=t;throw new TypeError(`Conversion of ${i} to ${r} requires an explicit cast`)}function ii(e,t,r,i){const n=L(e);throw new TypeError(`${n} expects the sentinel value ${t} at ${i-1}, found at ${r}`)}function Je(e,t,r){const i=L(e);throw new TypeError(`${i} expects the sentinel value ${t} at ${r-1}`)}function to(e){const{constructor:{name:t}}=e;throw new TypeError(`${t} cannot be modified`)}function Jt(e,t){const r=wi(t);throw new TypeError(`Expected ${oe(e)}, received ${r}`)}function ro(e,t){const r=L(e);let i;if(t!=null){const n=typeof t,c=n==="object"&&t.constructor!==Object?`${t.constructor.name} object`:n;i=`${Vi(c)} ${c}`}else i=t+"";throw new TypeError(`${r} cannot point to ${i}`)}function so(e,t){throw new TypeError("Pointers in fixed memory cannot point to garbage-collected object")}function io(e,t){const r=Es(e);throw new TypeError(`${r} cannot represent the value given: ${t}`)}function no(e,t){const{name:r}=e;throw new RangeError(`Index exceeds the size of ${r??"array"}: ${t}`)}function ni(e,t,r){if(r instanceof RangeError)no(e,t);else throw r}function oo(e){throw new Error(xs(e))}function xs(e){try{const t=e.replace(/(\p{Uppercase}+)(\p{Lowercase}*)/gu,(r,i,n)=>{if(i.length===1)return` ${i.toLocaleLowerCase()}${n}`;if(n){const c=i.substring(0,i.length-1),p=i.charAt(i.length-1).toLocaleLowerCase();return` ${c} ${p}${n}`}else return` ${i}`}).trimStart();return t.charAt(0).toLocaleUpperCase()+t.substring(1)}catch{return e}}function wi(e){const t=typeof e;let r;return t==="object"?r=e?Object.prototype.toString.call(e):"null":r=t,oe(r)}function oe(e){return`${Vi(e)} ${e}`}function Vi(e){return/^\W*[aeiou]/i.test(e)?"an":"a"}function zi(e,t="or"){const r=` ${t} `;return e.length>2?e.slice(0,-1).join(", ")+r+e[e.length-1]:e.join(r)}function ao(e,t){return Ri(e,t,()=>{const{byteSize:r}=t;if(r===void 0)return;const i=Es({type:v.Int,bitSize:r*8});if(e==="get"){const n=DataView.prototype[`get${i}`];return function(c,p){return!!n.call(this,c,p)}}else{const n=DataView.prototype[`set${i}`],c=r>4?1n:1,p=r>4?0n:0;return function(y,l,d){n.call(this,y,l?c:p,d)}}})}function vs(e,t){return Ri(e,t,r=>DataView.prototype[r])}function Oi(e,t){return vs(e,t)}function co(e,t){return vs(e,t)}function mo(e,t){return vs(e,t)}function Is(e,t){const{type:r,byteSize:i,typedArray:n}=e;let c;const p=t==null?void 0:t[Symbol.toStringTag];if(p==="DataView")c=t;else if(p==="ArrayBuffer"||p==="SharedArrayBuffer")c=new DataView(t);else if(n&&p===n.name||p==="Uint8ClampedArray"&&n===Uint8Array)c=new DataView(t.buffer,t.byteOffset,t.byteLength);else if(p==="Uint8Array"&&typeof Buffer=="function"&&t instanceof Buffer)c=new DataView(t.buffer,t.byteOffset,t.byteLength);else{const y=t==null?void 0:t[O];if(y&&(r===C.Array||r===C.Slice||r===C.Vector)){const{instance:{members:[l]}}=e,{byteSize:d,structure:{constructor:u}}=l,a=_i(t,u);if(a!==void 0){if(r===C.Slice||a*d===i)return y;Zt(e,null,t)}}}return c&&Ai(e,c),c}function Ai(e,t){const{type:r,byteSize:i}=e;(r===C.Slice?t.byteLength%i!==0:t.byteLength!==i)&&Si(e,t)}function _i(e,t){const{constructor:r}=e;if(r===t)return 1;if(r.child===t)return e.length}function Ue(e,t){const r=Is(e,t);return r||Ln(e),r}function uo(e){const{type:t,instance:{members:r}}=e;if(t===C.Primitive){const{type:i,byteSize:n}=r[0];if(i===v.Int)switch(n){case 1:return Int8Array;case 2:return Int16Array;case 4:return Int32Array;case 8:return BigInt64Array}else if(i===v.Uint)switch(n){case 1:return Uint8Array;case 2:return Uint16Array;case 4:return Uint32Array;case 8:return BigUint64Array}else if(i===v.Float)switch(n){case 4:return Float32Array;case 8:return Float64Array}}else if(t===C.Array||t===C.Slice||t===C.Vector){const{structure:{typedArray:i}}=r[0];return i}return null}function Qt(e){return e.typedArray=uo(e)}function lo(e,t){const r=e==null?void 0:e[Symbol.toStringTag];return!!t&&r===t.name}function po(e,t){const r=t[Ee];if(r){const i=e==null?void 0:e[Symbol.toStringTag];if(r.includes(i))return!0}return!!(t.child&&_i(e,t.child)!==void 0)}function er(e){const{typedArray:t}=e,r=[];return t&&(r.push(t.name),r.push("DataView"),t===Uint8Array&&(r.push("Uint8ClampedArray"),r.push("ArrayBuffer"),r.push("SharedArrayBuffer"))),r}function yo(e,t){const r=e==null?void 0:e[Symbol.toStringTag];return r==="DataView"||r==="ArrayBuffer"||r==="SharedArrayBuffer"?!0:!!(t&&r===t.name)}function Es(e){const{type:t,bitSize:r,byteSize:i,structure:n}=e;if((n==null?void 0:n.name)==="usize")return"USize";if((n==null?void 0:n.name)==="isize")return"ISize";if(t===v.Int)return`${r<=32?"":"Big"}Int${r}`;if(t===v.Uint)return`${r<=32?"":"Big"}Uint${r}`;if(t===v.Float)return`Float${r}`;if(t===v.Bool)return`Bool${i!==void 0?i*8:1}`;if(t===v.Void)return"Null"}function Ri(e,t,r){const{type:i,bitOffset:n,bitSize:c}=t,p=n&7,y=Es(t),l=zo(t)?"":`Bit${p}`,d=`${e}${y}${l}`;let u=oi[d];if(!u){if(i===v.Int&&y==="ISize"||i===v.Uint&&y==="USize"){if(c===64){const a=i===v.Int?"BigInt64":"BigUint64",m=`${e}${a}`;if(e==="get"){const g=r(m),f=BigInt(Number.MIN_SAFE_INTEGER),b=BigInt(Number.MAX_SAFE_INTEGER);u=function(z,h){const q=g.call(this,z,h);return f<=q&&q<=b?Number(q):q}}else{const g=r(m);u=function(f,b,z){typeof b=="number"&&(b=BigInt(b)),g.call(this,f,b,z)}}}else if(c===32){const a=i===v.Int?"Int32":"Uint32",m=`${e}${a}`;if(e==="get")u=r(m);else{const g=r(m);u=function(f,b,z){typeof b=="bigint"&&(b=Number(b)),g.call(this,f,b,z)}}}}else u=r(d);u&&u.name!==d&&Object.defineProperty(u,"name",{value:d,configurable:!0,writable:!1}),oi[d]=u}return u}const oi={},v={Void:0,Bool:1,Int:2,Uint:3,Float:4,EnumerationItem:5,Object:6,Type:7,Comptime:8},ce=Array(Object.values(v).length);function fo(){ce[v.Bool]=Oo}function bo(){ce[v.Int]=Ao}function ho(){ce[v.Uint]=_o}function go(){ce[v.Float]=Ro}function So(){ce[v.EnumerationItem]=qo}function wo(){ce[v.Object]=jo}function Vo(){ce[v.Type]=Po}function zo({bitOffset:e,bitSize:t,byteSize:r}){return r!==void 0||!(e&7)&&!(t&7)||t===0}function H(e,t={}){const r=ce[e.type];return{get:r("get",e,t),set:r("set",e,t)}}function Oo(e,t,r){return Te(e,t,r,ao)}function Ao(e,t,r){const i=qi(r,Oi);return Te(e,t,r,i)}function _o(e,t,r){const i=qi(r,co);return Te(e,t,r,i)}function qi(e,t){return function(r,i){const{runtimeSafety:n=!0}=e,c=t(r,i);if(n&&r==="set"){const{min:p,max:y}=Co(i);return function(l,d,u){(d<p||d>y)&&io(i,d),c.call(this,l,d,u)}}return c}}function Ro(e,t,r){return Te(e,t,r,mo)}function qo(e,t,r){const i=Uo(Oi);return Te(e,t,r,i)}function Uo(e){return function(t,r){let{bitSize:i,byteSize:n}=r;n&&(i=n*8);const c={type:v.Int,bitSize:i,byteSize:n},p=e(t,c),{structure:y}=r;return t==="get"?function(l,d){const{constructor:u}=y,a=p.call(this,l,d),m=u(a);return m||Fn(y,a),m}:function(l,d,u){const{constructor:a}=y;let m;d instanceof a?m=d:m=a(d),m||Kn(y,d),p.call(this,l,m.valueOf(),u)}}}function jo(e,t,r){const{structure:i,slot:n}=t;let c=!1;switch(i.type){case C.ErrorUnion:case C.Optional:c=!0;break}return n!==void 0?e==="get"?c?function(){return this[Q][n].call(this).$}:function(){return this[Q][n].call(this)}:function(y){const l=this[Q][n].call(this);l.$=y}:e==="get"?c?function(y){return this[Q](y).$}:function(y){return this[Q](y)}:function(y,l){const d=this[Q](y);d.$=l}}function Po(e,t,r){const{structure:i}=t;if(e==="get")return function(){const{constructor:n}=i;return n}}function Te(e,t,r,i){const{littleEndian:n=!0}=r,{bitOffset:c,byteSize:p}=t,y=i(e,t);if(c!==void 0){const l=c>>3;return e==="get"?function(){try{return y.call(this[O],l,n)}catch(d){if(d instanceof TypeError&&F.call(this))return y.call(this[O],l,n);throw d}}:function(d){try{return y.call(this[O],l,d,n)}catch(u){if(u instanceof TypeError&&F.call(this))return y.call(this[O],l,d,n);throw u}}}else return e==="get"?function(l){try{return y.call(this[O],l*p,n)}catch(d){if(d instanceof TypeError&&F.call(this))return y.call(this[O],l*p,n);ni(t,l,d)}}:function(l,d){try{return y.call(this[O],l*p,d,n)}catch(u){if(u instanceof TypeError&&F.call(this))return y.call(this[O],l*p,d,n);ni(t,l,u)}}}function be(e){const{constructor:t,instance:{members:r}}=e;Object.defineProperties(t.prototype,{dataView:{...xo(e),configurable:!0},base64:{...vo(),configurable:!0},toJSON:{value:ci,configurable:!0,writable:!0},valueOf:{value:ci,configurable:!0,writable:!0}}),Ui(e)&&Object.defineProperty(t.prototype,"string",{...Io(e),configurable:!0}),ji(e)&&Object.defineProperty(t.prototype,"typedArray",{...Eo(e),configurable:!0})}function Ui(e){if(e.type===C.Array||e.type===C.Slice){const{type:t,bitSize:r}=e.instance.members[0];if(t===v.Uint&&(r===8||r===16))return!0}return!1}function ji(e){return!!e.typedArray}function tr(e){const t=["dataView","base64"];return Ui(e)&&t.push("string"),ji(e)&&t.push("typedArray"),t}function xo(e){const{type:t,byteSize:r,sentinel:i}=e,n=Z(r,t===C.Slice);return{get(){return F.call(this),this[O]},set(c){Pi(c),F.call(this);const p=this[O];p.byteLength!==c.byteLength&&Si(e,c,this),i==null||i.validateData(c,this.length),n(p,c)}}}function Pi(e){return(e==null?void 0:e[Symbol.toStringTag])!=="DataView"&&Jt("a DataView",e),e}function vo(){return{get(){const e=this.dataView,t=new Uint8Array(e.buffer,e.byteOffset,e.byteLength),r=String.fromCharCode.apply(null,t);return btoa(r)},set(e){this.dataView=xi(e)}}}function xi(e){typeof e!="string"&&Jt("a string",e);const t=atob(e),r=new Uint8Array(t.length);for(let i=0;i<r.byteLength;i++)r[i]=t.charCodeAt(i);return new DataView(r.buffer)}const ai={};function Io(e){const{sentinel:t,instance:{members:[r]}}=e,{byteSize:i}=r;return{get(){let n=ai[i];n||(n=ai[i]=new TextDecoder(`utf-${i*8}`));const c=this.dataView,p=i===1?Int8Array:Int16Array,y=new p(c.buffer,c.byteOffset,this.length),l=n.decode(y);return(t==null?void 0:t.value)===void 0?l:l.slice(0,-1)},set(n){this.dataView=vi(n,i,t==null?void 0:t.value)}}}let As;function vi(e,t,r){typeof e!="string"&&Jt("a string",e),r!==void 0&&e.charCodeAt(e.length-1)!==r&&(e=e+String.fromCharCode(r));let i;if(t===1)As||(As=new TextEncoder(`utf-${t*8}`)),i=As.encode(e);else if(t===2){const{length:n}=e;i=new Uint16Array(n);for(let c=0;c<n;c++)i[c]=e.charCodeAt(c)}return new DataView(i.buffer)}function Eo(e){const{typedArray:t}=e;return{get(){const r=this.dataView,i=r.byteLength/t.BYTES_PER_ELEMENT;return new t(r.buffer,r.byteOffset,i)},set(r){this.dataView=Ii(r,t)}}}function Ii(e,t){return lo(e,t)||Jt(t.name,e),new DataView(e.buffer,e.byteOffset,e.byteLength)}function ci(){const e=new WeakMap;function t(r){if(r[Symbol.iterator]){const i=[];for(const n of r)i.push(t(n));return i}else if(r&&(typeof r=="object"||typeof r=="function")){let i=e.get(r);if(!i){i={},e.set(r,i);for(const[n,c]of Object.entries(r)){const p=t(c);p!==void 0&&(i[n]=p)}return i}return i}else return r}return t(this.$)}function To(e){const{byteSize:t,instance:{members:[r]},options:i}=e;Qt(e);const n=e.constructor=function(u){const a=this instanceof n;let m,g;if(a?(arguments.length===0&&de(e),m=this,g=new DataView(new ArrayBuffer(t))):(m=Object.create(n.prototype),g=Ue(e,u)),m[O]=g,a)y.call(m,u);else return m},c=Z(t),p=tr(e),y=function(u){if(u instanceof n)F.call(this),F.call(u),c(this[O],u[O]);else if(u&&typeof u=="object"){for(const m of Object.keys(u))m in this||Ps(e,m);let a=0;for(const m of p)m in u&&a++;if(a===0){const m=Ti(r);Yt(e,m,u)}for(const m of p)m in u&&(this[m]=u[m])}else u!==void 0&&(this.$=u)},{get:l,set:d}=H(r,i);return Object.defineProperties(n.prototype,{$:{get:l,set:d,configurable:!0},[Symbol.toPrimitive]:{value:l,configurable:!0,writable:!0}}),Object.defineProperty(n,Ee,{value:er(e)}),be(e),n}function Co(e){const{type:t,bitSize:r}=e,i=t===v.Int;let n=i?r-1:r;if(r<=32){const c=2**n-1;return{min:i?-(2**n):0,max:c}}else{n=BigInt(n);const c=2n**n-1n;return{min:i?-(2n**n):0n,max:c}}}function Ei({type:e,bitSize:t}){if(e===v.Int||e===v.Uint)return t<=32?Number:BigInt;if(e===v.Float)return Number;if(e===v.Bool)return Boolean}function Ti(e){const t=Ei(e);if(t)return typeof t(0)}function $o(e){const{byteSize:t,instance:{members:[r]},isConst:i,options:n}=e,{runtimeSafety:c=!0}=n,{structure:p}=r,y=p.type===C.Slice,l=p.type===C.Pointer,d=y?t/2:t,u={name:"usize",byteSize:d},a=H({type:v.Uint,bitOffset:0,bitSize:d*8,byteSize:d,structure:u},n).set,m=y?H({type:v.Uint,bitOffset:d*8,bitSize:d*8,byteSize:d,structure:u},n).set:null,g=e.constructor=function(b){const z=this===ne,h=this===Us;let q=this instanceof g,E,$;if(q)arguments.length===0&&de(e),E=this,$=new DataView(new ArrayBuffer(t));else if(E=Object.create(g.prototype),z||h)$=Ue(e,b);else{const B=p.constructor;ui(b,B)?(q=!0,b=b["*"]):y?(q=!0,b=B(b)):Qn()}return E[O]=$,E[x]={0:null},E[ne]=z,q&&f.call(E,b),No.call(E,i,l)},f=function(b){if(b instanceof g)Qe(this)?f.call(this,b[x][0]):fe.call(this,b);else{const z=p.constructor;if(ui(b,z))!i&&b.constructor.const&&eo(e,b),fe.call(this,b);else{if(!(b instanceof z))if(po(b,z)){const h=Is(p,b);b=z(h)}else if(y){const h=new z(b);if(c&&p.typedArray&&yo(b==null?void 0:b.buffer)){const q=oe(p.typedArray.name),E=oe(b.constructor.name);console.warn(`Implicitly creating ${q} from ${E}`)}b=h}else ro(e,b);if(Qe(this))if(Qe(b)){const{address:h}=Qe(b);a.call(this,h),m&&m.call(this,b.length)}else so();this[x][0]=b}}};return Object.defineProperties(g.prototype,{"*":{get:ko,set:i?void 0:Do,configurable:!0},$:{get:Ci,set:f,configurable:!0},valueOf:{value:Bo,configurable:!0,writable:!0},[W]:{value:Mo}}),Object.defineProperties(g,{child:{get:()=>p.constructor},const:{value:i}}),g}function Ci(){return this[qe]}function fe(e){this[x][0]=e[x][0]}function mi(){this[x][0]=null}function ko(){return this[x][0].$}function Do(e){const t=this[x][0];t.$=e}function Bo(){return this[x][0].$.valueOf()}function Mo(e,t,r){r.call(this,t)}function ui(e,t){var r;return((r=e==null?void 0:e.constructor)==null?void 0:r.child)===t&&e["*"]}function Qe(e){var t;return(t=e==null?void 0:e[O])==null?void 0:t[O]}function No(e,t){const r=t?{}:e?Lo:$i,i=new Proxy(this,r);return Object.defineProperty(this,qe,{value:i}),i}const pe={$:!0,"*":!0,constructor:!0,valueOf:!0,[ne]:!0,[x]:!0,[O]:!0,[qe]:!0,[W]:!0,[Symbol.toStringTag]:!0,[Symbol.toPrimitive]:!0},$i={get(e,t){return pe[t]?e[t]:e[x][0][t]},set(e,t,r){return pe[t]?e[t]=r:e[x][0][t]=r,!0},deleteProperty(e,t){return pe[t]?delete e[t]:delete e[x][0][t],!0},has(e,t){return pe[t]||t in e[x][0]},ownKeys(e){return[...Object.getOwnPropertyNames(e[x][0]),qe,W]},getOwnPropertyDescriptor(e,t){return pe[t]?Object.getOwnPropertyDescriptor(e,t):Object.getOwnPropertyDescriptor(e[x][0],t)}},Lo={...$i,set(e,t,r){return pe[t]?e[t]=r:to(e),!0},getOwnPropertyDescriptor(e,t){if(pe[t])return Object.getOwnPropertyDescriptor(e,t);{const r=Object.getOwnPropertyDescriptor(e[x][0],t);return r!=null&&r.set&&(r.set=void 0),r}}};function Fo(e){const{length:t,byteSize:r,instance:{members:[i]},hasPointer:n,options:c}=e;Qt(e);const p=i.type===v.Object,y=e.constructor=function(f){const b=this instanceof y;let z,h;return b?(arguments.length===0&&de(e),z=this,h=new DataView(new ArrayBuffer(r))):(z=Object.create(y.prototype),h=Ue(e,f)),z[O]=h,z[ue]=null,z[le]=null,p&&(z[x]={}),b&&a.call(z,f),Ni.call(z)},{structure:l}=i,d=Z(r),u=tr(e),a=function(f){if(f instanceof y)F.call(this),F.call(f),d(this[O],f[O]),n&&this[W](!0,f,fe);else if(typeof f=="string"&&u.includes("string")&&(f={string:f}),f!=null&&f[Symbol.iterator]){let b=f.length;typeof b!="number"&&(f=[...f],b=f.length),b!==t&&Zt(e,this,f);let z=0;for(const h of f)g.call(this,z++,h)}else if(f&&typeof f=="object"){for(const z of Object.keys(f))z in this||throwNoProperty(e,z);let b=0;for(const z of u)z in f&&b++;b===0&&he(e,f);for(const z of u)z in f&&(this[z]=f[z])}else f!==void 0&&he(e,f)},{get:m,set:g}=H(i,c);return Object.defineProperties(y.prototype,{get:{value:m,configurable:!0,writable:!0},set:{value:g,configurable:!0,writable:!0},length:{value:t,configurable:!0},$:{get:Ci,set:a,configurable:!0},[Symbol.iterator]:{value:Bi,configurable:!0,writable:!0},entries:{value:Mi,configurable:!0,writable:!0}}),Object.defineProperties(y,{child:{get:()=>l.constructor},[Ee]:{value:er(e)}}),p&&(ki(e),n&&Di(e)),be(e),y}function ki(e){const{constructor:{prototype:t},instance:{members:[r]}}=e,{byteSize:i,structure:n}=r;Object.defineProperty(t,Q,{value:function(y){let l=this[x][y];if(!l){const{constructor:d}=n,u=this[O],m=u.byteOffset+i*y,g=new DataView(u.buffer,m,i);l=this[x][y]=d.call(Us,g)}return l}})}function Di(e){const{constructor:{prototype:t}}=e;Object.defineProperty(t,W,{value:function(n,c,p){for(let y=0,l=this.length;y<l;y++){const d=c==null?void 0:c[x][y],u=n?this[Q](y):this[x][y];u&&u[W](n,d,p)}}})}function Bi(){const e=this[js]??this,t=this.length;let r=0;return{next(){let i,n;return r<t?(i=e.get(r),n=!1,r++):n=!0,{value:i,done:n}}}}function Ko(){const e=this[js]??this,t=this.length;let r=0;return{next(){let i,n;return r<t?(i=[r,e.get(r)],n=!1,r++):n=!0,{value:i,done:n}}}}function Mi(){return{[Symbol.iterator]:Ko.bind(this),length:this.length}}function Ni(){const e=new Proxy(this,Go);return Object.defineProperty(this,qe,{value:e}),e}const Go={get(e,t){const r=typeof t=="symbol"?0:t|0;if(r!==0||r==t)return e.get(r);switch(t){case"get":return e[ue]||(e[ue]=e.get.bind(e)),e[ue];case"set":return e[le]||(e[le]=e.set.bind(e)),e[le];case js:return e;default:return e[t]}},set(e,t,r){const i=typeof t=="symbol"?0:t|0;if(i!==0||i==t)e.set(i,r);else switch(t){case"get":e[ue]=r;break;case"set":e[le]=r;break;default:e[t]=r}return!0},deleteProperty(e,t){const r=typeof t=="symbol"?0:t|0;if(r!==0||r==t)return!1;switch(t){case"get":delete e[ue];break;case"set":delete e[le];break;default:delete e[t]}return!0},has(e,t){const r=typeof t=="symbol"?0:t|0;return r!==0||r==t?r>=0&&r<e.length:e[t]},ownKeys(e){const t=[];for(let r=0,i=e.length;r<i;r++)t.push(`${r}`);return t.push("length",qe),t},getOwnPropertyDescriptor(e,t){const r=typeof t=="symbol"?0:t|0;if(r!==0||r==t){if(r>=0&&r<e.length)return{value:e.get(r),enumerable:!0,writable:!0,configurable:!0}}else return Object.getOwnPropertyDescriptor(e,t)}};function Li(e){const{constructor:t,static:{members:r,template:i},options:n}=e,c={};for(const p of r){let{get:y,set:l}=H(p,n);const{type:d,slot:u,structure:{isConst:a}}=p;if(d===v.Object){const m=y;y=function(){return m.call(this)["*"]},l=a?void 0:function(g){const f=m.call(this);f["*"]=g},c[u]=()=>i[x][u]}Object.defineProperty(t,p.name,{get:y,set:l,configurable:!0,enumerable:!0})}Object.defineProperty(t,Q,{value:c})}function Fi(e){const{constructor:t,instance:{methods:r},static:{methods:i}}=e;for(const n of i){const{name:c,argStruct:p,thunk:y}=n,l=function(...d){const{constructor:u}=p,a=new u(d);return li(y,a)};Object.defineProperty(l,"name",{value:c,writable:!1}),Object.defineProperty(t,c,{value:l,configurable:!0,writable:!0})}for(const n of r){const{name:c,argStruct:p,thunk:y}=n,l=function(...d){const{constructor:u}=p,a=new u([this,...d]);return li(y,a)};Object.defineProperty(l,"name",{value:c,writable:!1}),Object.defineProperty(Object.prototype,c,{value:l,configurable:!0,writable:!0})}}function li(e,t){{const r=e(t);if(r!==void 0){if(r instanceof Promise)return r.then(()=>t.retval);oo(r)}}return t.retval}function Wo(e){const{byteSize:t,instance:{members:r,template:i},hasPointer:n,options:c}=e,p={};for(const f of r)if(f.type===v.Comptime){const{slot:b}=f,h=i[x][b]["*"];p[f.name]={value:h,configurable:!0,enumerable:!0},delete i[x][b]}else{const{get:b,set:z}=H(f,c);p[f.name]={get:b,set:z,configurable:!0,enumerable:!0}}const y=Object.keys(p),l=!!r.find(f=>f.type===v.Object),d=e.constructor=function(f){const b=this instanceof d;let z,h;if(b?(arguments.length===0&&de(e),z=this,h=new DataView(new ArrayBuffer(t))):(z=Object.create(d.prototype),h=Is(e,f)),z[O]=h,Object.defineProperties(z,p),l&&(z[x]={}),b)g.call(z,f);else return z},u=Z(t),a=tr(e),m=r.filter(f=>f.isRequired).map(f=>f.name),g=function(f){if(f instanceof d)F.call(this),F.call(f),u(this[O],f[O]),n&&this[W](!0,f,fe);else if(f&&typeof f=="object"){let b=0;for(const q of y)q in f&&b++;let z=0;for(const q of m)q in f&&z++;let h=0;if(!f[O])for(const q of a)q in f&&h++;for(const q of Object.keys(f))q in this||Ps(e,q);if(h===0&&z<m.length&&Yn(e,f),i&&h===0&&b<y.length&&(u(this[O],i[O]),n&&this[W](!0,i,fe)),h>0)for(const q of a)q in f&&(this[q]=f[q]);else if(b>0)for(const q of y)q in f&&(this[q]=f[q])}else f!==void 0&&Yt(e,"object",f)};return Object.defineProperty(d.prototype,"$",{get:Ts,set:g,configurable:!0}),be(e),l&&(Cs(e),n&&Ki(e)),Li(e),Fi(e),d}function Ts(){return this}function Cs(e){const{constructor:{prototype:t},instance:{members:r}}=e,i=r.filter(c=>c.type===v.Object),n={};for(const{slot:c,bitOffset:p,byteSize:y,structure:l}of i)n[c]=function(){let u=this[x][c];if(!u){const{constructor:a}=l,m=this[O],f=m.byteOffset+(p>>3),b=new DataView(m.buffer,f,y);u=this[x][c]=a.call(Us,b)}return u};Object.defineProperty(t,Q,{value:n})}function Ki(e){const{constructor:{prototype:t},instance:{members:r}}=e,i=r.filter(c=>c.structure.hasPointer);Object.defineProperty(t,W,{value:function(p,y,l){var d;for(const{slot:u}of i){let a;if(y&&(a=(d=y[x])==null?void 0:d[u],!a))continue;const m=p?this[Q][u].call(this):this[x][u];m&&m[W](p,a,l)}}})}function Ho(e){const{byteSize:t,instance:{members:r},options:i,hasPointer:n}=e,c=!!r.find(m=>m.type===v.Object),p=e.constructor=function(m){const g=this instanceof p;let f,b;if(g?(arguments.length===0&&de(e),f=this,b=new DataView(new ArrayBuffer(t))):(f=Object.create(p.prototype),b=Ue(e,m)),f[O]=b,c&&(f[x]={}),g)l.call(this,m);else return f},y=Z(t),l=function(m){m instanceof p?(y(this[O],m[O]),n&&a.call(this)&&this[W](!0,m,fe)):this.$=m},{get:d,set:u,check:a}=Xo(r,t,i);return Object.defineProperty(p.prototype,"$",{get:d,set:u,configurable:!0}),c&&(Cs(e),n&&Ki(e)),be(e),p}function Xo(e,t,r){const{get:i,set:n}=H(e[0],r),{get:c,set:p}=H(e[1],r),{structure:y}=e[1],{constructor:l}=y,d=vn(t);return{get:function(){var a;const u=c.call(this);if(u!==0){const m=l(u);throw m||Xn(y,u),(a=this[W])==null||a.call(this,!1,null,mi),m}else return i.call(this)},set:function(u){var a;u instanceof Error?(u instanceof l||Hn(y),d(this[O]),p.call(this,u.index),(a=this[W])==null||a.call(this,!1,null,mi)):(n.call(this,u),p.call(this,0))},check:function(){return c.call(this)===0}}}let Gi;function Yo(e){const{name:t,instance:{members:r}}=e,i=Gi,n=e.constructor=function(l){this instanceof n&&Wn(e);const u=Number(l);return i[u]};Object.setPrototypeOf(n.prototype,Error.prototype);const c=function(){return this[Ze]},p=function(){return"Error"};Object.defineProperties(n.prototype,{index:{get:c,configurable:!0},[Symbol.toStringTag]:{get:p,configurable:!0}});let y;for(const[l,{name:d,slot:u}]of r.entries()){let a=i[u];if(a){if(!(a instanceof n)){y||(y=r.map(f=>f.slot));const m=a.constructor,g=Object.values(m);if(g.every(f=>y.includes(f[Ze])))Object.setPrototypeOf(m.prototype,n.prototype);else{Object.setPrototypeOf(n.prototype,m.prototype);for(const f of g)y.includes(f[Ze])&&Object.setPrototypeOf(f,n.prototype)}}}else{a=Object.create(n.prototype);const m=xs(d);Object.defineProperties(a,{message:{value:m,configurable:!0,enumerable:!0,writable:!1},[Ze]:{value:u}}),i[u]=a}Object.defineProperties(n,{[d]:{value:a,configurable:!0,enumerable:!0,writable:!0}})}return n}function Zo(){Gi={}}function Jo(e){const{instance:{members:t,template:r},options:i}=e,n=Ei(t[0]),{get:c}=H(t[0],i),p=t.length,y={},l=e.constructor=function(a){if(this instanceof l&&Gn(e),typeof a=="number"||typeof a=="bigint"){let g=-1;if(u)g=Number(a);else{const f=n(a);for(let b=0;b<p;b++)if(c.call(l,b)===f){g=b;break}}return y[g]}else{if(a&&typeof a=="object"&&a[si])return a[si];if(typeof a=="string")return l[a];Yt(e,["number","string","tagged union"],a)}};Object.defineProperties(l,{[O]:{value:r[O]},[Vn]:{value:y}});const d=function(){const a=this[ri];return c.call(l,a)};Object.defineProperties(l.prototype,{[Symbol.toPrimitive]:{value:d,configurable:!0,writable:!0},$:{get:d,configurable:!0}});const u=(()=>{try{for(let a=0;a<p;a++)if(c.call(l,a)!==a)return!1;return!0}catch{return!1}})();for(const[a,{name:m}]of t.entries()){const g=Object.create(l.prototype);Object.defineProperties(g,{[ri]:{value:a},[wn]:{value:m}}),Object.defineProperties(l,{[m]:{value:g,configurable:!0,enumerable:!0,writable:!0}}),y[a]=g}return be(e),Li(e),Fi(e),l}function Qo(e){const{instance:{members:[t]},hasPointer:r,options:i}=e,n=Qt(e),c=t.type===v.Object,{byteSize:p,structure:y}=t,l=ta(e,i);l&&(e.sentinel=l);const d=e.constructor=function(h){const q=this instanceof d;let E;if(q)arguments.length===0&&de(e),E=this,f.call(E,h);else{E=Object.create(d.prototype);const $=Ue(e,h);m.call(E,$,$.byteLength/p,this)}return Ni.call(E)},u=Z(p,!0),a=tr(e),m=function(h,q,E=null){h||(h=new DataView(new ArrayBuffer(q*p))),this[O]=h,this[ue]=null,this[le]=null,this[_s]=q,c&&(this[x]={})},g=function(h,q){q!==this[_s]&&Zt(e,this,h)},f=function(h){let q=!this.hasOwnProperty(O);if(h instanceof d)q?m.call(this,null,h.length):g.call(this,h,h.length),F.call(this),F.call(h),u(this[O],h[O]),r&&this[W](!0,h,fe);else if(typeof h=="string"&&a.includes("string")&&(h={string:h}),h!=null&&h[Symbol.iterator]){let E=h.length;typeof E!="number"&&(h=[...h],E=h.length),this[O]?g.call(this,h,E):m.call(this,null,E);let $=0;for(const B of h)l==null||l.validateValue(B,$,E),z.call(this,$++,B)}else if(typeof h=="number")q&&h>=0&&isFinite(h)?m.call(this,null,h):he(e,h,q);else if(h&&typeof h=="object"){for(const $ of Object.keys(h))$ in this||Ps(e,$);let E=0;for(const $ of a)$ in h&&E++;E===0&&he(e,h);for(const $ of a)if($ in h)if(q){let B,K=!0;switch($){case"dataView":B=h[$],Pi(B);break;case"typedArray":B=Ii(h[$],n);break;case"string":B=vi(h[$],p,l==null?void 0:l.value),K=!1;break;case"base64":B=xi(h[$]),K=!1;break}Ai(e,B);const xe=B.byteLength/p;l==null||l.validateData(B,xe),K?(m.call(this,null,xe),u(this[O],B)):m.call(this,B,xe),q=!1}else this[$]=h[$]}else h!==void 0&&he(e,h)},{get:b,set:z}=H(t,i);return Object.defineProperties(d.prototype,{get:{value:b,configurable:!0,writable:!0},set:{value:z,configurable:!0,writable:!0},length:{get:ea,configurable:!0},$:{get:Ts,set:f,configurable:!0},[Symbol.iterator]:{value:Bi,configurable:!0,writable:!0},entries:{value:Mi,configurable:!0,writable:!0}}),Object.defineProperties(d,{child:{get:()=>y.constructor},[Ee]:{value:er(e)}}),c&&(ki(e),r&&Di(e)),be(e),d}function ea(){return this[_s]}function ta(e,t){const{runtimeSafety:r=!0}=t,{instance:{members:[i,n],template:c}}=e;if(!n)return;const{get:p}=H(n,t),y=p.call(c,0),{get:l}=H(i,t);return{value:y,validateValue:r?function(a,m,g){a===y&&m!==g-1?ii(e,a,m,g):a!==y&&m===g-1&&Je(e,y,m)}:function(a,m,g){a!==y&&m===g-1&&Je(e,y,g)},validateData:r?function(a,m){const g={[O]:a};for(let f=0;f<m;f++){const b=l.call(g,f);b===y&&f!==m-1?ii(e,y,f,m):b!==y&&f===m-1&&Je(e,y,m)}}:function(a,m){const g={[O]:a};if(m>0){const f=m-1;l.call(g,f)!==y&&Je(e,y,m)}}}}function ra(e){const{length:t,byteSize:r,instance:{members:[i]},options:n}=e;Qt(e);const c=e.constructor=function(u){const a=this instanceof c;let m,g;if(a?(arguments.length===0&&de(e),m=this,g=new DataView(new ArrayBuffer(r))):(m=Object.create(c.prototype),g=Ue(e,u)),m[O]=g,a)d.call(m,u);else return m},{bitSize:p,structure:y}=i,l=Z(r),d=function(u){if(u instanceof c)F.call(this),F.call(u),l(this[O],u[O]);else if(u!=null&&u[Symbol.iterator]){let a=u.length;typeof a!="number"&&(u=[...u],a=u.length),a!==t&&Zt(e,this,u);let m=0;for(const g of u)this[m++]=g}else u!==void 0&&he(e,u)};for(let u=0,a=0;u<t;u++,a+=p){const{get:m,set:g}=H({...i,bitOffset:a},n);Object.defineProperty(c.prototype,u,{get:m,set:g,configurable:!0})}return Object.defineProperties(c.prototype,{length:{value:t,configurable:!0},$:{get:Ts,set:d,configurable:!0},[Symbol.iterator]:{value:sa,configurable:!0,writable:!0},entries:{value:na,configurable:!0,writable:!0}}),Object.defineProperties(c,{child:{get:()=>y.constructor},[Ee]:{value:er(e)}}),be(e),c}function sa(){const e=this,t=this.length;let r=0;return{next(){let i,n;return r<t?(i=e[r],n=!1,r++):n=!0,{value:i,done:n}}}}function ia(){const e=this,t=this.length;let r=0;return{next(){let i,n;return r<t?(i=[r,e[r]],n=!1,r++):n=!0,{value:i,done:n}}}}function na(){return{[Symbol.iterator]:ia.bind(this),length:this.length}}function oa(e){const{byteSize:t,instance:{members:r},options:i}=e,n=!!r.find(d=>d.type===v.Object),c=e.constructor=function(d){const u=new DataView(new ArrayBuffer(t));this[O]=u,n&&(this[x]={}),l.call(this,d)},p=r.slice(0,-1).map(d=>d.name),y=p.length,l=function(d){d.length!==y&&Zn(e,d.length);for(const[u,a]of p.entries())try{this[a]=d[u]}catch(m){Jn(e,u,m)}};for(const d of r){const u=H(d,i);Object.defineProperty(c.prototype,d.name,u)}return n&&Cs(e),c}const C={Primitive:0,Array:1,Struct:2,ArgStruct:3,ExternUnion:4,BareUnion:5,TaggedUnion:6,ErrorUnion:7,ErrorSet:8,Enumeration:9,Optional:10,Pointer:11,Slice:12,Vector:13,Opaque:14,Function:15},ee=Array(Object.values(C).length);function aa(){ee[C.Primitive]=To}function ca(){ee[C.Array]=Fo}function ma(){ee[C.Struct]=Wo}function ua(){ee[C.ErrorUnion]=Ho}function la(){ee[C.ErrorSet]=Yo}function pa(){ee[C.Enumeration]=Jo}function ya(){ee[C.Pointer]=$o}function fa(){ee[C.Slice]=Qo}function da(){ee[C.Vector]=ra}function ba(){ee[C.ArgStruct]=oa}function L(e){let t=e.name;return t=t.replace(/{.*}/,""),t=t.replace(/[^. ]*?\./g,""),t}function ha(e){try{const t=ee[e.type],r=t(e);return typeof r=="function"&&(Object.defineProperties(r,{name:{value:L(e),writable:!1}}),r.prototype.hasOwnProperty(Symbol.toStringTag)||Object.defineProperties(r.prototype,{[Symbol.toStringTag]:{value:e.name,configurable:!0,writable:!1}})),r}catch(t){throw console.error(t),t}}const pi={Auto:0,Copy:1,Link:2};async function ga(e,t={}){const{resolve:r,reject:i,promise:n,...c}=t;try{const p=await e,y=await Sa(p,c);r(y)}catch(p){i(p)}return n}async function Sa(e,t={}){const{omitFunctions:r=!1,slots:i={},variables:n,methodRunner:c,writeBack:p=!0}=t;let y=0,l=null,d=null,u=0,a=null,m=null;const g=new TextDecoder,f={};let b=0;const z=i,h=()=>{},E={env:{_startCall:en,_endCall:tn,_allocMemory:rn,_freeMemory:sn,_getMemory:on,_getMemoryOffset:an,_getMemoryLength:cn,_wrapMemory:mn,_createString:un,_getPointerStatus:ln,_setPointerStatus:pn,_readGlobalSlot:yn,_readObjectSlot:fn,_writeObjectSlot:dn,_createDataView:gn,_writeToConsole:Sn,_writeGlobalSlot:h,_setObjectPropertyString:h,_setObjectPropertyInteger:h,_setObjectPropertyBoolean:h,_setObjectPropertyObject:h,_beginStructure:h,_attachMember:h,_attachMethod:h,_attachTemplate:h,_finalizeStructure:h,_createObject:h,_createTemplate:h}},$=e[Symbol.toStringTag]==="Response"?WebAssembly.instantiateStreaming(e,E):WebAssembly.instantiate(e,E);let{instance:B}=await $,{memory:K,define:xe,run:Hs,alloc:ws,free:Vs,safe:Zi}=B.exports,te="",zs=0;Xs();{for(const[_,T]of Object.entries(n))Js(T,Number(_));c[0]=function(_,T){const I=me(T),M=Hs(I,_);M!==0&&Qi(M)};const w=new WeakRef(B);return{abandon:()=>{B=K=xe=ws=Vs=Zi=null,Hs=function(){throw new Error("WebAssembly instance was abandoned")};for(const _ of Object.values(n))Qs(_)},released:()=>!w.deref()}}function Xs(){y!==1&&(y=1,l={0:null},d=new WeakMap),u!==1&&(u=1,a={0:null},m={})}function Ys(w,V){const A=new Uint8Array(K.buffer,w,V);return g.decode(A)}function Ji(w,V){const A=Ys(w,V);let _=m[A];return _===void 0&&(_=m[A]=u++,a[_]=A),_}function me(w){const V=y++;return l[V]=w,d.set(w,V),V}function Zs(w){const V=d.get(w);return V!==void 0?V:me(w)}function Js(w,V){const A=w[O],_=A.byteLength;if(_===0)return;const T=new DataView(K.buffer,V,_);if(p&&Z(A.byteLength)(T,A),T[O]={memory:K,address:V,len:_},w[O]=T,w.hasOwnProperty(ne)){const I=w[x][0],M=T.getUint32(0,!0);Js(I,M)}}function Qs(w){const V=w[O],A=V.byteLength;if(A===0||!V[O])return;const _=new DataView(new ArrayBuffer(A));if(Z(V.byteLength)(_,V),w[O]=_,w.hasOwnProperty(ne)){const I=w[x][0];Qs(I)}}function Qi(w){const V=a[w],A=xs(V);throw new Error(A)}function en(w){f[w]={bufferMap:new Map},b++}function tn(w){const V=f[w];for(const[A,{address:_,len:T,ptrAlign:I,copy:M,shadow:re}]of V.bufferMap){if(M){const se=new DataView(K.buffer,_,T);M(A,se)}re&&Vs(w,_,T,I)}delete f[w],b--,b===0&&(Xs(),te&&(console.log(te),te="",clearTimeout(zs)))}function rn(w,V,A){if(V===0)return null;const _=ws(w,V,A),{bufferMap:T}=f[w],I=new ArrayBuffer(V),M=new DataView(I),re=Z(V);return new DataView(K.buffer,_,V),T.set(M,{address:_,len:V,ptrAlign:A,copy:re,shadow:!0}),_}function sn(w,V,A,_){const{bufferMap:T}=f[w];for(const[I,{address:M}]of T)V===M&&(T.delete(I),Vs(w,V,A,_))}function nn({address:w},V){const A=(1<<V)-1;return(w&A)!==0}function on(w,V,A,_){let I=l[V][O];if(!I)return 0;const M=I[O];if(M)return me(M);{const re=f[w];let se=re.bufferMap.get(I);if(!se){const ie=I.byteLength;if(ie===0)return me({address:0,len:0});for(const[J,Os]of re.bufferMap)if(I.buffer===J.buffer){if(J.byteOffset<=I.byteOffset&&I.byteOffset+ie<=J.byteOffset+J.byteLength){se={address:Os.address+(I.byteOffset-J.byteOffset),len:ie,copy:null,ptrAlign:A,shadow:!1};break}else if(!(J.byteOffset>=I.byteOffset+ie||I.byteOffset>=J.byteOffset+J.byteLength))return 0}if(se){if(nn(se,A))return 0}else{const J=ws(w,ie,A),Os=new DataView(K.buffer,J,ie),ei=I.byteLength===ie?I:new DataView(I.buffer),ti=Z(ie);ti(Os,ei),se={address:J,len:ie,copy:_?null:ti,ptrAlign:A,shadow:!0}}re.bufferMap.set(I,se)}return me(se)}}function an(w){return l[w].address}function cn(w){return l[w].len}function mn(w,V){const A=l[w];let _=l[V],T;{const{constructor:I}=A;T=I.call(ne,_)}return me(T)}function un(w,V){return Ji(w,V)}function ln(w){const A=l[w][ne];return typeof A!="boolean"?-1:A?1:0}function pn(w,V){const A=l[w];A[ne]=!!V}function yn(w){const V=z[w];return V?Zs(V):0}function fn(w,V){const _=l[w][x][V];return _?Zs(_):0}function dn(w,V,A){const _=l[w];_[x][V]=l[A]}function bn(w,V,A){const _=new ArrayBuffer(A),T=new DataView(_);if(A>0){const I=Z(A),M=new DataView(K.buffer,V,A);I(T,M)}return w.bufferMap.set(T,{address:V,len:A,copy:null,ptrAlign:0,shadow:!1}),T}function hn(w,V,A,_){if(_===pi.Copy)return bn(w,V,A);if(_===pi.Auto){for(const[T,{address:I,len:M}]of w.bufferMap)if(I<=V&&V+A<=I+M){if(A===M)return T;{const re=V-I;return new DataView(T.buffer,re,A)}}}{const T=new DataView(K.buffer,V,A);return T[O]={memory:K,address:V,len:A},T}}function gn(w,V,A,_){const T=f[w];return me(hn(T,V,A,_))}function Sn(w,V){const A=Ys(w,V),_=A.lastIndexOf(`
`);_===-1?te+=A:(console.log(te+A.substring(0,_)),te=A.substring(_+1)),clearTimeout(zs),te&&(zs=setTimeout(()=>{console.log(te),te=""},250))}}function wa(e){const t={},r={};Zo();for(const a of e){for(const m of[a.static,a.instance])m.template&&(m.template=i(m.template));for(const m of a.static.methods)m.thunk=u(m.thunk);ha(a),t[a.slot]=a}function i(a){const m={};if(a.memory){const{array:g,offset:f,length:b}=a.memory;m[O]=new DataView(g.buffer,f,b)}return a.slots&&(m[x]=n({},a.slots)),m}function n(a,m){for(const[g,f]of Object.entries(m))a[g]=c(f);return a}function c(a){let m;if(a.memory){const{array:b,offset:z,length:h}=a.memory;m=new DataView(b.buffer,z,h)}else{const{byteSize:b}=a.structure;m=new DataView(new ArrayBuffer(b))}const{constructor:g}=a.structure,f=g.call(ne,m);return a.slots&&n(f[x],a.slots),a.address!==void 0&&(r[a.address]=f),f}let p,y;const l=new Promise((a,m)=>{p=a,y=m}),d={0:function(a,m){return l.then(()=>d[0].call(this,a,m))}};function u(a){return function(m){return d[0](a,m)}}return{promise:l,resolve:p,reject:y,slots:t,variables:r,methodRunner:d}}aa();ca();ya();da();ma();fa();pa();la();ua();ba();ho();wo();bo();Vo();go();fo();So();const o={constructor:null,typedArray:null,type:0,name:void 0,byteSize:4,align:2,isConst:!1,hasPointer:!1,instance:{members:[],methods:[],template:null},static:{members:[],methods:[],template:null},options:{runtimeSafety:!1}},s={type:0,isRequired:!0},k={},rr={},sr={},et={},ir={},nr={},tt={},U={},ae={},or={},ar={},rt={},cr={},R={},mr={},st={},ur={},it={},lr={},nt={},pr={},yr={},ot={},fr={},at={},N={},j={},S={},Ce={},$e={},ge={},dr={},ct={},br={},mt={},hr={},gr={},ut={},Sr={},lt={},wr={},Vr={},pt={},zr={},yt={},D={},X={},Or={},Ar={},ft={},_r={},dt={},ke={},De={},Se={},Rr={},bt={},qr={},Ur={},ht={},jr={},gt={},Be={},Me={},we={},Pr={},St={},Ve={},Ne={},ze={},Le={},Oe={},Fe={},Ae={},xr={},vr={},wt={},Ir={},Vt={},Ke={},Ge={},_e={},Er={},zt={},je={},Tr={},Ot={},Cr={},At={},$r={},_t={},kr={},Rt={},Dr={},Br={},qt={},Mr={},Ut={},Nr={},Lr={},jt={},Fr={},Pt={},Kr={},Gr={},xt={},Wr={},vt={},Hr={},It={},Xr={},Yr={},Et={},Zr={},Tt={},Jr={},Qr={},Ct={},es={},$t={},ts={},rs={},kt={},ss={},Dt={},is={},ns={},Bt={},os={},Mt={},as={},Nt={},cs={},ms={},Lt={},us={},Ft={},ls={},Kt={},We={},Re={},ps={},Gt={},ys={},Wt={},$s={},Pe={},fs={},ds={},Y={},bs={},ve={},Ht={},He={},hs={},gs={},Xt={},Xe={},Ye={},ks={},Ds={},Bs={},Ms={},Ns={},Ls={},Fs={};Object.assign(k,{...o,name:"u8",length:1,byteSize:1,align:0,instance:{members:[{...s,type:3,isRequired:!1,bitOffset:0,bitSize:8,byteSize:1,structure:k}],methods:[],template:null},slot:5});Object.assign(rr,{...o,type:1,name:"[19:0]u8",length:19,byteSize:20,align:0,instance:{members:[{...s,type:3,isRequired:!1,bitSize:8,byteSize:1,structure:k}],methods:[],template:null},slot:4});Object.assign(sr,{...o,type:11,name:"*const [19:0]u8",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:rr}],methods:[],template:null},slot:3});Object.assign(et,{...o,type:11,name:"**const [19:0]u8",length:1,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:sr}],methods:[],template:null},slot:2});Object.assign(ir,{...o,type:1,name:"[11:0]u8",length:11,byteSize:12,align:0,instance:{members:[{...s,type:3,isRequired:!1,bitSize:8,byteSize:1,structure:k}],methods:[],template:null},slot:8});Object.assign(nr,{...o,type:11,name:"*const [11:0]u8",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:ir}],methods:[],template:null},slot:7});Object.assign(tt,{...o,type:11,name:"**const [11:0]u8",length:1,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:nr}],methods:[],template:null},slot:6});Object.assign(U,{...o,name:"i32",length:1,instance:{members:[{...s,type:2,isRequired:!1,bitOffset:0,bitSize:32,byteSize:4,structure:U}],methods:[],template:null},slot:10});Object.assign(ae,{...o,type:11,name:"*i32",length:1,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:U}],methods:[],template:null},slot:9});Object.assign(or,{...o,type:1,name:"[18:0]u8",length:18,byteSize:19,align:0,instance:{members:[{...s,type:3,isRequired:!1,bitSize:8,byteSize:1,structure:k}],methods:[],template:null},slot:13});Object.assign(ar,{...o,type:11,name:"*const [18:0]u8",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:or}],methods:[],template:null},slot:12});Object.assign(rt,{...o,type:11,name:"**const [18:0]u8",length:1,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:ar}],methods:[],template:null},slot:11});Object.assign(cr,{...o,type:13,name:"@Vector(2, i32)",length:2,byteSize:8,align:3,instance:{members:[{...s,type:2,isRequired:!1,bitSize:32,byteSize:4,structure:U}],methods:[],template:null},slot:33});Object.assign(R,{...o,type:11,name:"*const i32",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:U}],methods:[],template:null},slot:106});const Va=new Uint8Array([]),za=new Uint8Array([120,30,16,0]),yi=new Uint8Array([100,0,0,0]),Oa=new Uint8Array([120,30,16,0]);Object.assign(mr,{...o,type:2,name:"struct{comptime comptime_int = 100, comptime comptime_int = 100}",length:1,byteSize:0,align:0,instance:{members:[{...s,type:8,isRequired:!1,slot:0,name:"0",structure:R},{...s,type:8,isRequired:!1,slot:1,name:"1",structure:R}],methods:[],template:{memory:{array:Va},slots:{0:{structure:R,memory:{array:za},slots:{0:{structure:U,memory:{array:yi},address:1056376}}},1:{structure:R,memory:{array:Oa},slots:{0:{structure:U,memory:{array:yi},address:1056376}}}}}},slot:90});Object.assign(st,{...o,type:11,name:"*const struct{comptime comptime_int = 100, comptime comptime_int = 100}",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:mr}],methods:[],template:null},slot:89});const Aa=new Uint8Array([]),_a=new Uint8Array([116,30,16,0]),fi=new Uint8Array([160,15,0,0]),Ra=new Uint8Array([116,30,16,0]);Object.assign(ur,{...o,type:2,name:"struct{comptime comptime_int = 4000, comptime comptime_int = 4000}",length:1,byteSize:0,align:0,instance:{members:[{...s,type:8,isRequired:!1,slot:0,name:"0",structure:R},{...s,type:8,isRequired:!1,slot:1,name:"1",structure:R}],methods:[],template:{memory:{array:Aa},slots:{0:{structure:R,memory:{array:_a},slots:{0:{structure:U,memory:{array:fi},address:1056372}}},1:{structure:R,memory:{array:Ra},slots:{0:{structure:U,memory:{array:fi},address:1056372}}}}}},slot:92});Object.assign(it,{...o,type:11,name:"*const struct{comptime comptime_int = 4000, comptime comptime_int = 4000}",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:ur}],methods:[],template:null},slot:91});const qa=new Uint8Array([]),Ua=new Uint8Array([112,30,16,0]),di=new Uint8Array([168,2,0,0]),ja=new Uint8Array([112,30,16,0]);Object.assign(lr,{...o,type:2,name:"struct{comptime comptime_int = 680, comptime comptime_int = 680}",length:1,byteSize:0,align:0,instance:{members:[{...s,type:8,isRequired:!1,slot:0,name:"0",structure:R},{...s,type:8,isRequired:!1,slot:1,name:"1",structure:R}],methods:[],template:{memory:{array:qa},slots:{0:{structure:R,memory:{array:Ua},slots:{0:{structure:U,memory:{array:di},address:1056368}}},1:{structure:R,memory:{array:ja},slots:{0:{structure:U,memory:{array:di},address:1056368}}}}}},slot:94});Object.assign(nt,{...o,type:11,name:"*const struct{comptime comptime_int = 680, comptime comptime_int = 680}",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:lr}],methods:[],template:null},slot:93});Object.assign(pr,{...o,type:1,name:"[26:0]u8",length:26,byteSize:27,align:0,instance:{members:[{...s,type:3,isRequired:!1,bitSize:8,byteSize:1,structure:k}],methods:[],template:null},slot:97});Object.assign(yr,{...o,type:11,name:"*const [26:0]u8",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:pr}],methods:[],template:null},slot:96});Object.assign(ot,{...o,type:11,name:"*const *const [26:0]u8",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:yr}],methods:[],template:null},slot:95});const Pa=new Uint8Array([]),xa=new Uint8Array([170,170,170,170]),P=new Uint8Array([]),va=new Uint8Array([170,170,170,170]),Ia=new Uint8Array([170,170,170,170]),Ea=new Uint8Array([72,31,16,0]),Ta=new Uint8Array([205,34,16,0]),Ca=new Uint8Array([79,117,116,112,117,116,32,115,105,122,101,32,111,102,32,102,105,110,97,108,32,105,109,97,103,101,0]);Object.assign(fr,{...o,type:2,name:'struct{comptime type: type = @Vector(2, i32), comptime minValue: struct{comptime comptime_int = 100, comptime comptime_int = 100} = .{100, 100}, comptime maxValue: struct{comptime comptime_int = 4000, comptime comptime_int = 4000} = .{4000, 4000}, comptime defaultValue: struct{comptime comptime_int = 680, comptime comptime_int = 680} = .{680, 680}, comptime description: *const [26:0]u8 = "Output size of final image"}',length:1,byteSize:0,align:0,instance:{members:[{...s,type:7,isRequired:!1,name:"type",structure:cr},{...s,type:8,isRequired:!1,slot:0,name:"minValue",structure:st},{...s,type:8,isRequired:!1,slot:1,name:"maxValue",structure:it},{...s,type:8,isRequired:!1,slot:2,name:"defaultValue",structure:nt},{...s,type:8,isRequired:!1,slot:3,name:"description",structure:ot}],methods:[],template:{memory:{array:Pa},slots:{0:{structure:st,memory:{array:xa},slots:{0:{structure:mr,memory:{array:P},address:-1431655766}}},1:{structure:it,memory:{array:va},slots:{0:{structure:ur,memory:{array:P},address:-1431655766}}},2:{structure:nt,memory:{array:Ia},slots:{0:{structure:lr,memory:{array:P},address:-1431655766}}},3:{structure:ot,memory:{array:Ea},slots:{0:{structure:yr,memory:{array:Ta},address:1056584,slots:{0:{structure:pr,memory:{array:Ca},address:1057485}}}}}}}},slot:42});Object.assign(at,{...o,type:11,name:'*const struct{comptime type: type = @Vector(2, i32), comptime minValue: struct{comptime comptime_int = 100, comptime comptime_int = 100} = .{100, 100}, comptime maxValue: struct{comptime comptime_int = 4000, comptime comptime_int = 4000} = .{4000, 4000}, comptime defaultValue: struct{comptime comptime_int = 680, comptime comptime_int = 680} = .{680, 680}, comptime description: *const [26:0]u8 = "Output size of final image"}',length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:fr}],methods:[],template:null},slot:41});Object.assign(N,{...o,name:"f32",length:1,instance:{members:[{...s,type:4,isRequired:!1,bitOffset:0,bitSize:32,byteSize:4,structure:N}],methods:[],template:null},slot:34});Object.assign(j,{...o,name:"f64",length:1,byteSize:8,align:3,instance:{members:[{...s,type:4,isRequired:!1,bitOffset:0,bitSize:64,byteSize:8,structure:j}],methods:[],template:null},slot:99});Object.assign(S,{...o,type:11,name:"*const f64",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:j}],methods:[],template:null},slot:98});Object.assign(Ce,{...o,type:1,name:"[41:0]u8",length:41,byteSize:42,align:0,instance:{members:[{...s,type:3,isRequired:!1,bitSize:8,byteSize:1,structure:k}],methods:[],template:null},slot:102});Object.assign($e,{...o,type:11,name:"*const [41:0]u8",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:Ce}],methods:[],template:null},slot:101});Object.assign(ge,{...o,type:11,name:"*const *const [41:0]u8",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:$e}],methods:[],template:null},slot:100});const $a=new Uint8Array([]),ka=new Uint8Array([64,31,16,0]),Da=new Uint8Array([154,153,153,153,153,153,185,63]),Ba=new Uint8Array([40,31,16,0]),Rs=new Uint8Array([0,0,0,0,0,0,89,64]),Ma=new Uint8Array([56,31,16,0]),Na=new Uint8Array([0,0,0,0,0,0,57,64]),La=new Uint8Array([48,31,16,0]),Fa=new Uint8Array([163,34,16,0]),Ka=new Uint8Array([84,104,101,32,105,110,110,101,114,32,114,97,100,105,117,115,32,111,102,32,116,104,101,32,114,101,112,101,97,116,105,110,103,32,97,110,110,117,108,97,114,0]);Object.assign(dr,{...o,type:2,name:'struct{comptime type: type = f32, comptime minValue: comptime_float = 0.1, comptime maxValue: comptime_float = 100, comptime defaultValue: comptime_float = 25, comptime description: *const [41:0]u8 = "The inner radius of the repeating annular"}',length:1,byteSize:0,align:0,instance:{members:[{...s,type:7,isRequired:!1,name:"type",structure:N},{...s,type:8,isRequired:!1,slot:0,name:"minValue",structure:S},{...s,type:8,isRequired:!1,slot:1,name:"maxValue",structure:S},{...s,type:8,isRequired:!1,slot:2,name:"defaultValue",structure:S},{...s,type:8,isRequired:!1,slot:3,name:"description",structure:ge}],methods:[],template:{memory:{array:$a},slots:{0:{structure:S,memory:{array:ka},slots:{0:{structure:j,memory:{array:Da},address:1056576}}},1:{structure:S,memory:{array:Ba},slots:{0:{structure:j,memory:{array:Rs},address:1056552}}},2:{structure:S,memory:{array:Ma},slots:{0:{structure:j,memory:{array:Na},address:1056568}}},3:{structure:ge,memory:{array:La},slots:{0:{structure:$e,memory:{array:Fa},address:1056560,slots:{0:{structure:Ce,memory:{array:Ka},address:1057443}}}}}}}},slot:44});Object.assign(ct,{...o,type:11,name:'*const struct{comptime type: type = f32, comptime minValue: comptime_float = 0.1, comptime maxValue: comptime_float = 100, comptime defaultValue: comptime_float = 25, comptime description: *const [41:0]u8 = "The inner radius of the repeating annular"}',length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:dr}],methods:[],template:null},slot:43});const Ga=new Uint8Array([]),Wa=new Uint8Array([80,30,16,0]),ye=new Uint8Array([0,0,0,0,0,0,240,63]),Ha=new Uint8Array([40,31,16,0]),Xa=new Uint8Array([40,31,16,0]),Ya=new Uint8Array([32,31,16,0]),Za=new Uint8Array([121,34,16,0]),Ja=new Uint8Array([84,104,101,32,111,117,116,101,114,32,114,97,100,105,117,115,32,111,102,32,116,104,101,32,114,101,112,101,97,116,105,110,103,32,97,110,110,117,108,97,114,0]);Object.assign(br,{...o,type:2,name:'struct{comptime type: type = f32, comptime minValue: comptime_float = 1, comptime maxValue: comptime_float = 100, comptime defaultValue: comptime_float = 100, comptime description: *const [41:0]u8 = "The outer radius of the repeating annular"}',length:1,byteSize:0,align:0,instance:{members:[{...s,type:7,isRequired:!1,name:"type",structure:N},{...s,type:8,isRequired:!1,slot:0,name:"minValue",structure:S},{...s,type:8,isRequired:!1,slot:1,name:"maxValue",structure:S},{...s,type:8,isRequired:!1,slot:2,name:"defaultValue",structure:S},{...s,type:8,isRequired:!1,slot:3,name:"description",structure:ge}],methods:[],template:{memory:{array:Ga},slots:{0:{structure:S,memory:{array:Wa},slots:{0:{structure:j,memory:{array:ye},address:1056336}}},1:{structure:S,memory:{array:Ha},slots:{0:{structure:j,memory:{array:Rs},address:1056552}}},2:{structure:S,memory:{array:Xa},slots:{0:{structure:j,memory:{array:Rs},address:1056552}}},3:{structure:ge,memory:{array:Ya},slots:{0:{structure:$e,memory:{array:Za},address:1056544,slots:{0:{structure:Ce,memory:{array:Ja},address:1057401}}}}}}}},slot:46});Object.assign(mt,{...o,type:11,name:'*const struct{comptime type: type = f32, comptime minValue: comptime_float = 1, comptime maxValue: comptime_float = 100, comptime defaultValue: comptime_float = 100, comptime description: *const [41:0]u8 = "The outer radius of the repeating annular"}',length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:br}],methods:[],template:null},slot:45});Object.assign(hr,{...o,type:1,name:"[55:0]u8",length:55,byteSize:56,align:0,instance:{members:[{...s,type:3,isRequired:!1,bitSize:8,byteSize:1,structure:k}],methods:[],template:null},slot:105});Object.assign(gr,{...o,type:11,name:"*const [55:0]u8",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:hr}],methods:[],template:null},slot:104});Object.assign(ut,{...o,type:11,name:"*const *const [55:0]u8",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:gr}],methods:[],template:null},slot:103});const Qa=new Uint8Array([]),ec=new Uint8Array([24,31,16,0]),tc=new Uint8Array([0,0,0,0,0,0,24,192]),rc=new Uint8Array([16,31,16,0]),sc=new Uint8Array([0,0,0,0,0,0,24,64]),ic=new Uint8Array([80,30,16,0]),nc=new Uint8Array([8,31,16,0]),oc=new Uint8Array([65,34,16,0]),ac=new Uint8Array([84,104,101,32,110,117,109,98,101,114,32,111,102,32,105,109,97,103,101,32,116,104,101,32,105,109,97,103,101,32,105,115,32,114,101,112,101,97,116,101,100,32,111,110,32,101,97,99,104,32,108,101,118,101,108,0]);Object.assign(Sr,{...o,type:2,name:'struct{comptime type: type = f32, comptime minValue: comptime_float = -6, comptime maxValue: comptime_float = 6, comptime defaultValue: comptime_float = 1, comptime description: *const [55:0]u8 = "The number of image the image is repeated on each level"}',length:1,byteSize:0,align:0,instance:{members:[{...s,type:7,isRequired:!1,name:"type",structure:N},{...s,type:8,isRequired:!1,slot:0,name:"minValue",structure:S},{...s,type:8,isRequired:!1,slot:1,name:"maxValue",structure:S},{...s,type:8,isRequired:!1,slot:2,name:"defaultValue",structure:S},{...s,type:8,isRequired:!1,slot:3,name:"description",structure:ut}],methods:[],template:{memory:{array:Qa},slots:{0:{structure:S,memory:{array:ec},slots:{0:{structure:j,memory:{array:tc},address:1056536}}},1:{structure:S,memory:{array:rc},slots:{0:{structure:j,memory:{array:sc},address:1056528}}},2:{structure:S,memory:{array:ic},slots:{0:{structure:j,memory:{array:ye},address:1056336}}},3:{structure:ut,memory:{array:nc},slots:{0:{structure:gr,memory:{array:oc},address:1056520,slots:{0:{structure:hr,memory:{array:ac},address:1057345}}}}}}}},slot:48});Object.assign(lt,{...o,type:11,name:'*const struct{comptime type: type = f32, comptime minValue: comptime_float = -6, comptime maxValue: comptime_float = 6, comptime defaultValue: comptime_float = 1, comptime description: *const [55:0]u8 = "The number of image the image is repeated on each level"}',length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:Sr}],methods:[],template:null},slot:47});Object.assign(wr,{...o,type:1,name:"[35:0]u8",length:35,byteSize:36,align:0,instance:{members:[{...s,type:3,isRequired:!1,bitSize:8,byteSize:1,structure:k}],methods:[],template:null},slot:109});Object.assign(Vr,{...o,type:11,name:"*const [35:0]u8",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:wr}],methods:[],template:null},slot:108});Object.assign(pt,{...o,type:11,name:"*const *const [35:0]u8",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:Vr}],methods:[],template:null},slot:107});const cc=new Uint8Array([]),mc=new Uint8Array([4,31,16,0]),uc=new Uint8Array([244,255,255,255]),lc=new Uint8Array([0,31,16,0]),pc=new Uint8Array([12,0,0,0]),yc=new Uint8Array([204,30,16,0]),Ie=new Uint8Array([1,0,0,0]),fc=new Uint8Array([252,30,16,0]),dc=new Uint8Array([29,34,16,0]),bc=new Uint8Array([84,104,101,32,110,117,109,98,101,114,32,111,102,32,115,116,114,97,110,100,115,32,111,102,32,116,104,101,32,115,112,105,114,97,108,0]);Object.assign(zr,{...o,type:2,name:'struct{comptime type: type = i32, comptime minValue: comptime_int = -12, comptime maxValue: comptime_int = 12, comptime defaultValue: comptime_int = 1, comptime description: *const [35:0]u8 = "The number of strands of the spiral"}',length:1,byteSize:0,align:0,instance:{members:[{...s,type:7,isRequired:!1,name:"type",structure:U},{...s,type:8,isRequired:!1,slot:0,name:"minValue",structure:R},{...s,type:8,isRequired:!1,slot:1,name:"maxValue",structure:R},{...s,type:8,isRequired:!1,slot:2,name:"defaultValue",structure:R},{...s,type:8,isRequired:!1,slot:3,name:"description",structure:pt}],methods:[],template:{memory:{array:cc},slots:{0:{structure:R,memory:{array:mc},slots:{0:{structure:U,memory:{array:uc},address:1056516}}},1:{structure:R,memory:{array:lc},slots:{0:{structure:U,memory:{array:pc},address:1056512}}},2:{structure:R,memory:{array:yc},slots:{0:{structure:U,memory:{array:Ie},address:1056460}}},3:{structure:pt,memory:{array:fc},slots:{0:{structure:Vr,memory:{array:dc},address:1056508,slots:{0:{structure:wr,memory:{array:bc},address:1057309}}}}}}}},slot:50});Object.assign(yt,{...o,type:11,name:'*const struct{comptime type: type = i32, comptime minValue: comptime_int = -12, comptime maxValue: comptime_int = 12, comptime defaultValue: comptime_int = 1, comptime description: *const [35:0]u8 = "The number of strands of the spiral"}',length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:zr}],methods:[],template:null},slot:49});Object.assign(D,{...o,name:"bool",length:1,byteSize:1,align:0,instance:{members:[{...s,type:1,isRequired:!1,bitOffset:0,bitSize:1,byteSize:1,structure:D}],methods:[],template:null},slot:27});Object.assign(X,{...o,type:11,name:"*const bool",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:D}],methods:[],template:null},slot:110});Object.assign(Or,{...o,type:1,name:"[50:0]u8",length:50,byteSize:51,align:0,instance:{members:[{...s,type:3,isRequired:!1,bitSize:8,byteSize:1,structure:k}],methods:[],template:null},slot:113});Object.assign(Ar,{...o,type:11,name:"*const [50:0]u8",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:Or}],methods:[],template:null},slot:112});Object.assign(ft,{...o,type:11,name:"*const *const [50:0]u8",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:Ar}],methods:[],template:null},slot:111});const hc=new Uint8Array([]),gc=new Uint8Array([180,30,16,0]),Ss=new Uint8Array([1]),Sc=new Uint8Array([248,30,16,0]),wc=new Uint8Array([234,33,16,0]),Vc=new Uint8Array([83,109,111,111,116,104,101,114,32,114,101,112,101,97,116,105,110,103,32,119,104,101,110,32,117,115,105,110,103,32,109,111,114,101,32,116,104,97,110,32,111,110,101,32,115,116,114,97,110,100,0]);Object.assign(_r,{...o,type:2,name:'struct{comptime type: type = bool, comptime defaultValue: bool = true, comptime description: *const [50:0]u8 = "Smoother repeating when using more than one strand"}',length:1,byteSize:0,align:0,instance:{members:[{...s,type:7,isRequired:!1,name:"type",structure:D},{...s,type:8,isRequired:!1,slot:0,name:"defaultValue",structure:X},{...s,type:8,isRequired:!1,slot:1,name:"description",structure:ft}],methods:[],template:{memory:{array:hc},slots:{0:{structure:X,memory:{array:gc},slots:{0:{structure:D,memory:{array:Ss},address:1056436}}},1:{structure:ft,memory:{array:Sc},slots:{0:{structure:Ar,memory:{array:wc},address:1056504,slots:{0:{structure:Or,memory:{array:Vc},address:1057258}}}}}}}},slot:52});Object.assign(dt,{...o,type:11,name:'*const struct{comptime type: type = bool, comptime defaultValue: bool = true, comptime description: *const [50:0]u8 = "Smoother repeating when using more than one strand"}',length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:_r}],methods:[],template:null},slot:51});Object.assign(ke,{...o,type:1,name:"[27:0]u8",length:27,byteSize:28,align:0,instance:{members:[{...s,type:3,isRequired:!1,bitSize:8,byteSize:1,structure:k}],methods:[],template:null},slot:116});Object.assign(De,{...o,type:11,name:"*const [27:0]u8",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:ke}],methods:[],template:null},slot:115});Object.assign(Se,{...o,type:11,name:"*const *const [27:0]u8",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:De}],methods:[],template:null},slot:114});const zc=new Uint8Array([]),Oc=new Uint8Array([88,30,16,0]),G=new Uint8Array([0,0,0,0,0,0,0,0]),Ac=new Uint8Array([240,30,16,0]),_c=new Uint8Array([0,0,0,0,0,0,62,64]),Rc=new Uint8Array([88,30,16,0]),qc=new Uint8Array([236,30,16,0]),Uc=new Uint8Array([206,33,16,0]),jc=new Uint8Array([79,118,101,114,97,108,108,32,105,109,97,103,101,32,109,97,103,110,105,102,105,99,97,116,105,111,110,0]);Object.assign(Rr,{...o,type:2,name:'struct{comptime type: type = f32, comptime minValue: comptime_float = 0, comptime maxValue: comptime_float = 30, comptime defaultValue: comptime_float = 0, comptime description: *const [27:0]u8 = "Overall image magnification"}',length:1,byteSize:0,align:0,instance:{members:[{...s,type:7,isRequired:!1,name:"type",structure:N},{...s,type:8,isRequired:!1,slot:0,name:"minValue",structure:S},{...s,type:8,isRequired:!1,slot:1,name:"maxValue",structure:S},{...s,type:8,isRequired:!1,slot:2,name:"defaultValue",structure:S},{...s,type:8,isRequired:!1,slot:3,name:"description",structure:Se}],methods:[],template:{memory:{array:zc},slots:{0:{structure:S,memory:{array:Oc},slots:{0:{structure:j,memory:{array:G},address:1056344}}},1:{structure:S,memory:{array:Ac},slots:{0:{structure:j,memory:{array:_c},address:1056496}}},2:{structure:S,memory:{array:Rc},slots:{0:{structure:j,memory:{array:G},address:1056344}}},3:{structure:Se,memory:{array:qc},slots:{0:{structure:De,memory:{array:Uc},address:1056492,slots:{0:{structure:ke,memory:{array:jc},address:1057230}}}}}}}},slot:54});Object.assign(bt,{...o,type:11,name:'*const struct{comptime type: type = f32, comptime minValue: comptime_float = 0, comptime maxValue: comptime_float = 30, comptime defaultValue: comptime_float = 0, comptime description: *const [27:0]u8 = "Overall image magnification"}',length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:Rr}],methods:[],template:null},slot:53});Object.assign(qr,{...o,type:1,name:"[22:0]u8",length:22,byteSize:23,align:0,instance:{members:[{...s,type:3,isRequired:!1,bitSize:8,byteSize:1,structure:k}],methods:[],template:null},slot:119});Object.assign(Ur,{...o,type:11,name:"*const [22:0]u8",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:qr}],methods:[],template:null},slot:118});Object.assign(ht,{...o,type:11,name:"*const *const [22:0]u8",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:Ur}],methods:[],template:null},slot:117});const Pc=new Uint8Array([]),xc=new Uint8Array([160,30,16,0]),Ks=new Uint8Array([0,0,0,0,0,128,118,192]),vc=new Uint8Array([152,30,16,0]),Gs=new Uint8Array([0,0,0,0,0,128,118,64]),Ic=new Uint8Array([88,30,16,0]),Ec=new Uint8Array([232,30,16,0]),Tc=new Uint8Array([183,33,16,0]),Cc=new Uint8Array([79,118,101,114,97,108,108,32,105,109,97,103,101,32,114,111,116,97,116,105,111,110,0]);Object.assign(jr,{...o,type:2,name:'struct{comptime type: type = f32, comptime minValue: comptime_float = -360, comptime maxValue: comptime_float = 360, comptime defaultValue: comptime_float = 0, comptime description: *const [22:0]u8 = "Overall image rotation"}',length:1,byteSize:0,align:0,instance:{members:[{...s,type:7,isRequired:!1,name:"type",structure:N},{...s,type:8,isRequired:!1,slot:0,name:"minValue",structure:S},{...s,type:8,isRequired:!1,slot:1,name:"maxValue",structure:S},{...s,type:8,isRequired:!1,slot:2,name:"defaultValue",structure:S},{...s,type:8,isRequired:!1,slot:3,name:"description",structure:ht}],methods:[],template:{memory:{array:Pc},slots:{0:{structure:S,memory:{array:xc},slots:{0:{structure:j,memory:{array:Ks},address:1056416}}},1:{structure:S,memory:{array:vc},slots:{0:{structure:j,memory:{array:Gs},address:1056408}}},2:{structure:S,memory:{array:Ic},slots:{0:{structure:j,memory:{array:G},address:1056344}}},3:{structure:ht,memory:{array:Ec},slots:{0:{structure:Ur,memory:{array:Tc},address:1056488,slots:{0:{structure:qr,memory:{array:Cc},address:1057207}}}}}}}},slot:56});Object.assign(gt,{...o,type:11,name:'*const struct{comptime type: type = f32, comptime minValue: comptime_float = -360, comptime maxValue: comptime_float = 360, comptime defaultValue: comptime_float = 0, comptime description: *const [22:0]u8 = "Overall image rotation"}',length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:jr}],methods:[],template:null},slot:55});Object.assign(Be,{...o,type:1,name:"[60:0]u8",length:60,byteSize:61,align:0,instance:{members:[{...s,type:3,isRequired:!1,bitSize:8,byteSize:1,structure:k}],methods:[],template:null},slot:122});Object.assign(Me,{...o,type:11,name:"*const [60:0]u8",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:Be}],methods:[],template:null},slot:121});Object.assign(we,{...o,type:11,name:"*const *const [60:0]u8",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:Me}],methods:[],template:null},slot:120});const $c=new Uint8Array([]),kc=new Uint8Array([204,30,16,0]),Dc=new Uint8Array([196,30,16,0]),Wi=new Uint8Array([3,0,0,0]),Bc=new Uint8Array([204,30,16,0]),Mc=new Uint8Array([228,30,16,0]),Nc=new Uint8Array([122,33,16,0]),Lc=new Uint8Array([83,117,112,101,114,32,115,97,109,112,108,105,110,103,32,113,117,97,108,105,116,121,46,32,78,117,109,98,101,114,32,111,102,32,115,97,109,112,108,101,115,32,115,113,117,97,114,101,100,32,112,101,114,32,112,105,120,101,108,46,0]);Object.assign(Pr,{...o,type:2,name:'struct{comptime type: type = i32, comptime minValue: comptime_int = 1, comptime maxValue: comptime_int = 3, comptime defaultValue: comptime_int = 1, comptime description: *const [60:0]u8 = "Super sampling quality. Number of samples squared per pixel."}',length:1,byteSize:0,align:0,instance:{members:[{...s,type:7,isRequired:!1,name:"type",structure:U},{...s,type:8,isRequired:!1,slot:0,name:"minValue",structure:R},{...s,type:8,isRequired:!1,slot:1,name:"maxValue",structure:R},{...s,type:8,isRequired:!1,slot:2,name:"defaultValue",structure:R},{...s,type:8,isRequired:!1,slot:3,name:"description",structure:we}],methods:[],template:{memory:{array:$c},slots:{0:{structure:R,memory:{array:kc},slots:{0:{structure:U,memory:{array:Ie},address:1056460}}},1:{structure:R,memory:{array:Dc},slots:{0:{structure:U,memory:{array:Wi},address:1056452}}},2:{structure:R,memory:{array:Bc},slots:{0:{structure:U,memory:{array:Ie},address:1056460}}},3:{structure:we,memory:{array:Mc},slots:{0:{structure:Me,memory:{array:Nc},address:1056484,slots:{0:{structure:Be,memory:{array:Lc},address:1057146}}}}}}}},slot:58});Object.assign(St,{...o,type:11,name:'*const struct{comptime type: type = i32, comptime minValue: comptime_int = 1, comptime maxValue: comptime_int = 3, comptime defaultValue: comptime_int = 1, comptime description: *const [60:0]u8 = "Super sampling quality. Number of samples squared per pixel."}',length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:Pr}],methods:[],template:null},slot:57});Object.assign(Ve,{...o,type:13,name:"@Vector(2, f32)",length:2,byteSize:8,align:3,instance:{members:[{...s,type:4,isRequired:!1,bitSize:32,byteSize:4,structure:N}],methods:[],template:null},slot:35});const Fc=new Uint8Array([]),Kc=new Uint8Array([104,30,16,0]),bi=new Uint8Array([0,0,0,0,0,0,105,192]),Gc=new Uint8Array([104,30,16,0]);Object.assign(Ne,{...o,type:2,name:"struct{comptime comptime_float = -200, comptime comptime_float = -200}",length:1,byteSize:0,align:0,instance:{members:[{...s,type:8,isRequired:!1,slot:0,name:"0",structure:S},{...s,type:8,isRequired:!1,slot:1,name:"1",structure:S}],methods:[],template:{memory:{array:Fc},slots:{0:{structure:S,memory:{array:Kc},slots:{0:{structure:j,memory:{array:bi},address:1056360}}},1:{structure:S,memory:{array:Gc},slots:{0:{structure:j,memory:{array:bi},address:1056360}}}}}},slot:124});Object.assign(ze,{...o,type:11,name:"*const struct{comptime comptime_float = -200, comptime comptime_float = -200}",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:Ne}],methods:[],template:null},slot:123});const Wc=new Uint8Array([]),Hc=new Uint8Array([96,30,16,0]),hi=new Uint8Array([0,0,0,0,0,0,105,64]),Xc=new Uint8Array([96,30,16,0]);Object.assign(Le,{...o,type:2,name:"struct{comptime comptime_float = 200, comptime comptime_float = 200}",length:1,byteSize:0,align:0,instance:{members:[{...s,type:8,isRequired:!1,slot:0,name:"0",structure:S},{...s,type:8,isRequired:!1,slot:1,name:"1",structure:S}],methods:[],template:{memory:{array:Wc},slots:{0:{structure:S,memory:{array:Hc},slots:{0:{structure:j,memory:{array:hi},address:1056352}}},1:{structure:S,memory:{array:Xc},slots:{0:{structure:j,memory:{array:hi},address:1056352}}}}}},slot:126});Object.assign(Oe,{...o,type:11,name:"*const struct{comptime comptime_float = 200, comptime comptime_float = 200}",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:Le}],methods:[],template:null},slot:125});const Yc=new Uint8Array([]),Zc=new Uint8Array([88,30,16,0]),Jc=new Uint8Array([88,30,16,0]);Object.assign(Fe,{...o,type:2,name:"struct{comptime comptime_float = 0, comptime comptime_float = 0}",length:1,byteSize:0,align:0,instance:{members:[{...s,type:8,isRequired:!1,slot:0,name:"0",structure:S},{...s,type:8,isRequired:!1,slot:1,name:"1",structure:S}],methods:[],template:{memory:{array:Yc},slots:{0:{structure:S,memory:{array:Zc},slots:{0:{structure:j,memory:{array:G},address:1056344}}},1:{structure:S,memory:{array:Jc},slots:{0:{structure:j,memory:{array:G},address:1056344}}}}}},slot:128});Object.assign(Ae,{...o,type:11,name:"*const struct{comptime comptime_float = 0, comptime comptime_float = 0}",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:Fe}],methods:[],template:null},slot:127});Object.assign(xr,{...o,type:1,name:"[40:0]u8",length:40,byteSize:41,align:0,instance:{members:[{...s,type:3,isRequired:!1,bitSize:8,byteSize:1,structure:k}],methods:[],template:null},slot:131});Object.assign(vr,{...o,type:11,name:"*const [40:0]u8",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:xr}],methods:[],template:null},slot:130});Object.assign(wt,{...o,type:11,name:"*const *const [40:0]u8",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:vr}],methods:[],template:null},slot:129});const Qc=new Uint8Array([]),em=new Uint8Array([170,170,170,170]),tm=new Uint8Array([170,170,170,170]),rm=new Uint8Array([170,170,170,170]),sm=new Uint8Array([224,30,16,0]),im=new Uint8Array([81,33,16,0]),nm=new Uint8Array([80,97,110,110,105,110,103,32,111,102,32,116,104,101,32,105,109,97,103,101,32,105,110,32,116,104,101,32,111,117,116,112,117,116,32,102,114,97,109,101,0]);Object.assign(Ir,{...o,type:2,name:'struct{comptime type: type = @Vector(2, f32), comptime minValue: struct{comptime comptime_float = -200, comptime comptime_float = -200} = .{-200, -200}, comptime maxValue: struct{comptime comptime_float = 200, comptime comptime_float = 200} = .{200, 200}, comptime defaultValue: struct{comptime comptime_float = 0, comptime comptime_float = 0} = .{0, 0}, comptime description: *const [40:0]u8 = "Panning of the image in the output frame"}',length:1,byteSize:0,align:0,instance:{members:[{...s,type:7,isRequired:!1,name:"type",structure:Ve},{...s,type:8,isRequired:!1,slot:0,name:"minValue",structure:ze},{...s,type:8,isRequired:!1,slot:1,name:"maxValue",structure:Oe},{...s,type:8,isRequired:!1,slot:2,name:"defaultValue",structure:Ae},{...s,type:8,isRequired:!1,slot:3,name:"description",structure:wt}],methods:[],template:{memory:{array:Qc},slots:{0:{structure:ze,memory:{array:em},slots:{0:{structure:Ne,memory:{array:P},address:-1431655766}}},1:{structure:Oe,memory:{array:tm},slots:{0:{structure:Le,memory:{array:P},address:-1431655766}}},2:{structure:Ae,memory:{array:rm},slots:{0:{structure:Fe,memory:{array:P},address:-1431655766}}},3:{structure:wt,memory:{array:sm},slots:{0:{structure:vr,memory:{array:im},address:1056480,slots:{0:{structure:xr,memory:{array:nm},address:1057105}}}}}}}},slot:60});Object.assign(Vt,{...o,type:11,name:'*const struct{comptime type: type = @Vector(2, f32), comptime minValue: struct{comptime comptime_float = -200, comptime comptime_float = -200} = .{-200, -200}, comptime maxValue: struct{comptime comptime_float = 200, comptime comptime_float = 200} = .{200, 200}, comptime defaultValue: struct{comptime comptime_float = 0, comptime comptime_float = 0} = .{0, 0}, comptime description: *const [40:0]u8 = "Panning of the image in the output frame"}',length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:Ir}],methods:[],template:null},slot:59});Object.assign(Ke,{...o,type:1,name:"[30:0]u8",length:30,byteSize:31,align:0,instance:{members:[{...s,type:3,isRequired:!1,bitSize:8,byteSize:1,structure:k}],methods:[],template:null},slot:134});Object.assign(Ge,{...o,type:11,name:"*const [30:0]u8",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:Ke}],methods:[],template:null},slot:133});Object.assign(_e,{...o,type:11,name:"*const *const [30:0]u8",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:Ge}],methods:[],template:null},slot:132});const om=new Uint8Array([]),am=new Uint8Array([170,170,170,170]),cm=new Uint8Array([170,170,170,170]),mm=new Uint8Array([170,170,170,170]),um=new Uint8Array([220,30,16,0]),lm=new Uint8Array([50,33,16,0]),pm=new Uint8Array([83,104,105,102,116,32,116,104,101,32,99,101,110,116,114,101,32,111,102,32,116,104,101,32,115,112,105,114,97,108,0]);Object.assign(Er,{...o,type:2,name:'struct{comptime type: type = @Vector(2, f32), comptime minValue: struct{comptime comptime_float = -200, comptime comptime_float = -200} = .{-200, -200}, comptime maxValue: struct{comptime comptime_float = 200, comptime comptime_float = 200} = .{200, 200}, comptime defaultValue: struct{comptime comptime_float = 0, comptime comptime_float = 0} = .{0, 0}, comptime description: *const [30:0]u8 = "Shift the centre of the spiral"}',length:1,byteSize:0,align:0,instance:{members:[{...s,type:7,isRequired:!1,name:"type",structure:Ve},{...s,type:8,isRequired:!1,slot:0,name:"minValue",structure:ze},{...s,type:8,isRequired:!1,slot:1,name:"maxValue",structure:Oe},{...s,type:8,isRequired:!1,slot:2,name:"defaultValue",structure:Ae},{...s,type:8,isRequired:!1,slot:3,name:"description",structure:_e}],methods:[],template:{memory:{array:om},slots:{0:{structure:ze,memory:{array:am},slots:{0:{structure:Ne,memory:{array:P},address:-1431655766}}},1:{structure:Oe,memory:{array:cm},slots:{0:{structure:Le,memory:{array:P},address:-1431655766}}},2:{structure:Ae,memory:{array:mm},slots:{0:{structure:Fe,memory:{array:P},address:-1431655766}}},3:{structure:_e,memory:{array:um},slots:{0:{structure:Ge,memory:{array:lm},address:1056476,slots:{0:{structure:Ke,memory:{array:pm},address:1057074}}}}}}}},slot:62});Object.assign(zt,{...o,type:11,name:'*const struct{comptime type: type = @Vector(2, f32), comptime minValue: struct{comptime comptime_float = -200, comptime comptime_float = -200} = .{-200, -200}, comptime maxValue: struct{comptime comptime_float = 200, comptime comptime_float = 200} = .{200, 200}, comptime defaultValue: struct{comptime comptime_float = 0, comptime comptime_float = 0} = .{0, 0}, comptime description: *const [30:0]u8 = "Shift the centre of the spiral"}',length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:Er}],methods:[],template:null},slot:61});Object.assign(je,{...o,type:13,name:"@Vector(4, f32)",length:4,byteSize:16,align:4,instance:{members:[{...s,type:4,isRequired:!1,bitSize:32,byteSize:4,structure:N}],methods:[],template:null},slot:36});const ym=new Uint8Array([]),fm=new Uint8Array([88,30,16,0]),dm=new Uint8Array([88,30,16,0]),bm=new Uint8Array([88,30,16,0]),hm=new Uint8Array([88,30,16,0]);Object.assign(Tr,{...o,type:2,name:"struct{comptime comptime_float = 0, comptime comptime_float = 0, comptime comptime_float = 0, comptime comptime_float = 0}",length:1,byteSize:0,align:0,instance:{members:[{...s,type:8,isRequired:!1,slot:0,name:"0",structure:S},{...s,type:8,isRequired:!1,slot:1,name:"1",structure:S},{...s,type:8,isRequired:!1,slot:2,name:"2",structure:S},{...s,type:8,isRequired:!1,slot:3,name:"3",structure:S}],methods:[],template:{memory:{array:ym},slots:{0:{structure:S,memory:{array:fm},slots:{0:{structure:j,memory:{array:G},address:1056344}}},1:{structure:S,memory:{array:dm},slots:{0:{structure:j,memory:{array:G},address:1056344}}},2:{structure:S,memory:{array:bm},slots:{0:{structure:j,memory:{array:G},address:1056344}}},3:{structure:S,memory:{array:hm},slots:{0:{structure:j,memory:{array:G},address:1056344}}}}}},slot:136});Object.assign(Ot,{...o,type:11,name:"*const struct{comptime comptime_float = 0, comptime comptime_float = 0, comptime comptime_float = 0, comptime comptime_float = 0}",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:Tr}],methods:[],template:null},slot:135});const gm=new Uint8Array([]),Sm=new Uint8Array([80,30,16,0]),wm=new Uint8Array([80,30,16,0]),Vm=new Uint8Array([80,30,16,0]),zm=new Uint8Array([80,30,16,0]);Object.assign(Cr,{...o,type:2,name:"struct{comptime comptime_float = 1, comptime comptime_float = 1, comptime comptime_float = 1, comptime comptime_float = 1}",length:1,byteSize:0,align:0,instance:{members:[{...s,type:8,isRequired:!1,slot:0,name:"0",structure:S},{...s,type:8,isRequired:!1,slot:1,name:"1",structure:S},{...s,type:8,isRequired:!1,slot:2,name:"2",structure:S},{...s,type:8,isRequired:!1,slot:3,name:"3",structure:S}],methods:[],template:{memory:{array:gm},slots:{0:{structure:S,memory:{array:Sm},slots:{0:{structure:j,memory:{array:ye},address:1056336}}},1:{structure:S,memory:{array:wm},slots:{0:{structure:j,memory:{array:ye},address:1056336}}},2:{structure:S,memory:{array:Vm},slots:{0:{structure:j,memory:{array:ye},address:1056336}}},3:{structure:S,memory:{array:zm},slots:{0:{structure:j,memory:{array:ye},address:1056336}}}}}},slot:138});Object.assign(At,{...o,type:11,name:"*const struct{comptime comptime_float = 1, comptime comptime_float = 1, comptime comptime_float = 1, comptime comptime_float = 1}",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:Cr}],methods:[],template:null},slot:137});const Om=new Uint8Array([]),Am=new Uint8Array([88,30,16,0]),_m=new Uint8Array([88,30,16,0]),Rm=new Uint8Array([88,30,16,0]),qm=new Uint8Array([80,30,16,0]);Object.assign($r,{...o,type:2,name:"struct{comptime comptime_float = 0, comptime comptime_float = 0, comptime comptime_float = 0, comptime comptime_float = 1}",length:1,byteSize:0,align:0,instance:{members:[{...s,type:8,isRequired:!1,slot:0,name:"0",structure:S},{...s,type:8,isRequired:!1,slot:1,name:"1",structure:S},{...s,type:8,isRequired:!1,slot:2,name:"2",structure:S},{...s,type:8,isRequired:!1,slot:3,name:"3",structure:S}],methods:[],template:{memory:{array:Om},slots:{0:{structure:S,memory:{array:Am},slots:{0:{structure:j,memory:{array:G},address:1056344}}},1:{structure:S,memory:{array:_m},slots:{0:{structure:j,memory:{array:G},address:1056344}}},2:{structure:S,memory:{array:Rm},slots:{0:{structure:j,memory:{array:G},address:1056344}}},3:{structure:S,memory:{array:qm},slots:{0:{structure:j,memory:{array:ye},address:1056336}}}}}},slot:140});Object.assign(_t,{...o,type:11,name:"*const struct{comptime comptime_float = 0, comptime comptime_float = 0, comptime comptime_float = 0, comptime comptime_float = 1}",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:$r}],methods:[],template:null},slot:139});const Um=new Uint8Array([]),jm=new Uint8Array([170,170,170,170]),Pm=new Uint8Array([170,170,170,170]),xm=new Uint8Array([170,170,170,170]),vm=new Uint8Array([216,30,16,0]),Im=new Uint8Array([19,33,16,0]),Em=new Uint8Array([83,101,116,32,116,104,101,32,82,71,66,65,32,98,97,99,107,103,114,111,117,110,100,32,99,111,108,111,117,114,0]);Object.assign(kr,{...o,type:2,name:'struct{comptime type: type = @Vector(4, f32), comptime minValue: struct{comptime comptime_float = 0, comptime comptime_float = 0, comptime comptime_float = 0, comptime comptime_float = 0} = .{0, 0, 0, 0}, comptime maxValue: struct{comptime comptime_float = 1, comptime comptime_float = 1, comptime comptime_float = 1, comptime comptime_float = 1} = .{1, 1, 1, 1}, comptime defaultValue: struct{comptime comptime_float = 0, comptime comptime_float = 0, comptime comptime_float = 0, comptime comptime_float = 1} = .{0, 0, 0, 1}, comptime description: *const [30:0]u8 = "Set the RGBA background colour"}',length:1,byteSize:0,align:0,instance:{members:[{...s,type:7,isRequired:!1,name:"type",structure:je},{...s,type:8,isRequired:!1,slot:0,name:"minValue",structure:Ot},{...s,type:8,isRequired:!1,slot:1,name:"maxValue",structure:At},{...s,type:8,isRequired:!1,slot:2,name:"defaultValue",structure:_t},{...s,type:8,isRequired:!1,slot:3,name:"description",structure:_e}],methods:[],template:{memory:{array:Um},slots:{0:{structure:Ot,memory:{array:jm},slots:{0:{structure:Tr,memory:{array:P},address:-1431655766}}},1:{structure:At,memory:{array:Pm},slots:{0:{structure:Cr,memory:{array:P},address:-1431655766}}},2:{structure:_t,memory:{array:xm},slots:{0:{structure:$r,memory:{array:P},address:-1431655766}}},3:{structure:_e,memory:{array:vm},slots:{0:{structure:Ge,memory:{array:Im},address:1056472,slots:{0:{structure:Ke,memory:{array:Em},address:1057043}}}}}}}},slot:64});Object.assign(Rt,{...o,type:11,name:'*const struct{comptime type: type = @Vector(4, f32), comptime minValue: struct{comptime comptime_float = 0, comptime comptime_float = 0, comptime comptime_float = 0, comptime comptime_float = 0} = .{0, 0, 0, 0}, comptime maxValue: struct{comptime comptime_float = 1, comptime comptime_float = 1, comptime comptime_float = 1, comptime comptime_float = 1} = .{1, 1, 1, 1}, comptime defaultValue: struct{comptime comptime_float = 0, comptime comptime_float = 0, comptime comptime_float = 0, comptime comptime_float = 1} = .{0, 0, 0, 1}, comptime description: *const [30:0]u8 = "Set the RGBA background colour"}',length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:kr}],methods:[],template:null},slot:63});Object.assign(Dr,{...o,type:1,name:"[44:0]u8",length:44,byteSize:45,align:0,instance:{members:[{...s,type:3,isRequired:!1,bitSize:8,byteSize:1,structure:k}],methods:[],template:null},slot:143});Object.assign(Br,{...o,type:11,name:"*const [44:0]u8",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:Dr}],methods:[],template:null},slot:142});Object.assign(qt,{...o,type:11,name:"*const *const [44:0]u8",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:Br}],methods:[],template:null},slot:141});const Tm=new Uint8Array([]),Cm=new Uint8Array([204,30,16,0]),$m=new Uint8Array([200,30,16,0]),Hi=new Uint8Array([20,0,0,0]),km=new Uint8Array([212,30,16,0]),Dm=new Uint8Array([9,0,0,0]),Bm=new Uint8Array([208,30,16,0]),Mm=new Uint8Array([230,32,16,0]),Nm=new Uint8Array([84,104,101,32,110,117,109,98,101,114,32,111,102,32,114,101,112,101,97,116,105,110,103,32,108,101,118,101,108,115,32,111,102,32,116,104,101,32,115,112,105,114,97,108,0]);Object.assign(Mr,{...o,type:2,name:'struct{comptime type: type = i32, comptime minValue: comptime_int = 1, comptime maxValue: comptime_int = 20, comptime defaultValue: comptime_int = 9, comptime description: *const [44:0]u8 = "The number of repeating levels of the spiral"}',length:1,byteSize:0,align:0,instance:{members:[{...s,type:7,isRequired:!1,name:"type",structure:U},{...s,type:8,isRequired:!1,slot:0,name:"minValue",structure:R},{...s,type:8,isRequired:!1,slot:1,name:"maxValue",structure:R},{...s,type:8,isRequired:!1,slot:2,name:"defaultValue",structure:R},{...s,type:8,isRequired:!1,slot:3,name:"description",structure:qt}],methods:[],template:{memory:{array:Tm},slots:{0:{structure:R,memory:{array:Cm},slots:{0:{structure:U,memory:{array:Ie},address:1056460}}},1:{structure:R,memory:{array:$m},slots:{0:{structure:U,memory:{array:Hi},address:1056456}}},2:{structure:R,memory:{array:km},slots:{0:{structure:U,memory:{array:Dm},address:1056468}}},3:{structure:qt,memory:{array:Bm},slots:{0:{structure:Br,memory:{array:Mm},address:1056464,slots:{0:{structure:Dr,memory:{array:Nm},address:1056998}}}}}}}},slot:66});Object.assign(Ut,{...o,type:11,name:'*const struct{comptime type: type = i32, comptime minValue: comptime_int = 1, comptime maxValue: comptime_int = 20, comptime defaultValue: comptime_int = 9, comptime description: *const [44:0]u8 = "The number of repeating levels of the spiral"}',length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:Mr}],methods:[],template:null},slot:65});Object.assign(Nr,{...o,type:1,name:"[25:0]u8",length:25,byteSize:26,align:0,instance:{members:[{...s,type:3,isRequired:!1,bitSize:8,byteSize:1,structure:k}],methods:[],template:null},slot:146});Object.assign(Lr,{...o,type:11,name:"*const [25:0]u8",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:Nr}],methods:[],template:null},slot:145});Object.assign(jt,{...o,type:11,name:"*const *const [25:0]u8",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:Lr}],methods:[],template:null},slot:144});const Lm=new Uint8Array([]),Fm=new Uint8Array([204,30,16,0]),Km=new Uint8Array([200,30,16,0]),Gm=new Uint8Array([196,30,16,0]),Wm=new Uint8Array([192,30,16,0]),Hm=new Uint8Array([204,32,16,0]),Xm=new Uint8Array([84,104,101,32,115,116,97,114,116,105,110,103,32,115,112,105,114,97,108,32,108,101,118,101,108,0]);Object.assign(Fr,{...o,type:2,name:'struct{comptime type: type = i32, comptime minValue: comptime_int = 1, comptime maxValue: comptime_int = 20, comptime defaultValue: comptime_int = 3, comptime description: *const [25:0]u8 = "The starting spiral level"}',length:1,byteSize:0,align:0,instance:{members:[{...s,type:7,isRequired:!1,name:"type",structure:U},{...s,type:8,isRequired:!1,slot:0,name:"minValue",structure:R},{...s,type:8,isRequired:!1,slot:1,name:"maxValue",structure:R},{...s,type:8,isRequired:!1,slot:2,name:"defaultValue",structure:R},{...s,type:8,isRequired:!1,slot:3,name:"description",structure:jt}],methods:[],template:{memory:{array:Lm},slots:{0:{structure:R,memory:{array:Fm},slots:{0:{structure:U,memory:{array:Ie},address:1056460}}},1:{structure:R,memory:{array:Km},slots:{0:{structure:U,memory:{array:Hi},address:1056456}}},2:{structure:R,memory:{array:Gm},slots:{0:{structure:U,memory:{array:Wi},address:1056452}}},3:{structure:jt,memory:{array:Wm},slots:{0:{structure:Lr,memory:{array:Hm},address:1056448,slots:{0:{structure:Nr,memory:{array:Xm},address:1056972}}}}}}}},slot:68});Object.assign(Pt,{...o,type:11,name:'*const struct{comptime type: type = i32, comptime minValue: comptime_int = 1, comptime maxValue: comptime_int = 20, comptime defaultValue: comptime_int = 3, comptime description: *const [25:0]u8 = "The starting spiral level"}',length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:Fr}],methods:[],template:null},slot:67});Object.assign(Kr,{...o,type:1,name:"[74:0]u8",length:74,byteSize:75,align:0,instance:{members:[{...s,type:3,isRequired:!1,bitSize:8,byteSize:1,structure:k}],methods:[],template:null},slot:149});Object.assign(Gr,{...o,type:11,name:"*const [74:0]u8",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:Kr}],methods:[],template:null},slot:148});Object.assign(xt,{...o,type:11,name:"*const *const [74:0]u8",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:Gr}],methods:[],template:null},slot:147});const Ym=new Uint8Array([]),Zm=new Uint8Array([180,30,16,0]),Jm=new Uint8Array([188,30,16,0]),Qm=new Uint8Array([129,32,16,0]),eu=new Uint8Array([69,110,97,98,108,101,32,102,111,114,32,105,109,97,103,101,115,32,119,105,116,104,32,116,114,97,110,115,112,97,114,101,110,116,32,109,105,100,100,108,101,32,97,114,101,97,115,32,40,115,117,99,104,32,97,115,32,97,32,112,105,99,116,117,114,101,32,102,114,97,109,101,41,46,0]);Object.assign(Wr,{...o,type:2,name:'struct{comptime type: type = bool, comptime defaultValue: bool = true, comptime description: *const [74:0]u8 = "Enable for images with transparent middle areas (such as a picture frame)."}',length:1,byteSize:0,align:0,instance:{members:[{...s,type:7,isRequired:!1,name:"type",structure:D},{...s,type:8,isRequired:!1,slot:0,name:"defaultValue",structure:X},{...s,type:8,isRequired:!1,slot:1,name:"description",structure:xt}],methods:[],template:{memory:{array:Ym},slots:{0:{structure:X,memory:{array:Zm},slots:{0:{structure:D,memory:{array:Ss},address:1056436}}},1:{structure:xt,memory:{array:Jm},slots:{0:{structure:Gr,memory:{array:Qm},address:1056444,slots:{0:{structure:Kr,memory:{array:eu},address:1056897}}}}}}}},slot:70});Object.assign(vt,{...o,type:11,name:'*const struct{comptime type: type = bool, comptime defaultValue: bool = true, comptime description: *const [74:0]u8 = "Enable for images with transparent middle areas (such as a picture frame)."}',length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:Wr}],methods:[],template:null},slot:69});const tu=new Uint8Array([]),ru=new Uint8Array([180,30,16,0]),su=new Uint8Array([184,30,16,0]),iu=new Uint8Array([68,32,16,0]),nu=new Uint8Array([69,110,97,98,108,101,32,102,111,114,32,105,109,97,103,101,115,32,119,105,116,104,32,116,114,97,110,115,112,97,114,101,110,116,32,97,114,101,97,115,32,97,114,111,117,110,100,32,116,104,101,32,111,117,116,115,105,100,101,46,0]);Object.assign(Hr,{...o,type:2,name:'struct{comptime type: type = bool, comptime defaultValue: bool = true, comptime description: *const [60:0]u8 = "Enable for images with transparent areas around the outside."}',length:1,byteSize:0,align:0,instance:{members:[{...s,type:7,isRequired:!1,name:"type",structure:D},{...s,type:8,isRequired:!1,slot:0,name:"defaultValue",structure:X},{...s,type:8,isRequired:!1,slot:1,name:"description",structure:we}],methods:[],template:{memory:{array:tu},slots:{0:{structure:X,memory:{array:ru},slots:{0:{structure:D,memory:{array:Ss},address:1056436}}},1:{structure:we,memory:{array:su},slots:{0:{structure:Me,memory:{array:iu},address:1056440,slots:{0:{structure:Be,memory:{array:nu},address:1056836}}}}}}}},slot:72});Object.assign(It,{...o,type:11,name:'*const struct{comptime type: type = bool, comptime defaultValue: bool = true, comptime description: *const [60:0]u8 = "Enable for images with transparent areas around the outside."}',length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:Hr}],methods:[],template:null},slot:71});Object.assign(Xr,{...o,type:1,name:"[52:0]u8",length:52,byteSize:53,align:0,instance:{members:[{...s,type:3,isRequired:!1,bitSize:8,byteSize:1,structure:k}],methods:[],template:null},slot:152});Object.assign(Yr,{...o,type:11,name:"*const [52:0]u8",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:Xr}],methods:[],template:null},slot:151});Object.assign(Et,{...o,type:11,name:"*const *const [52:0]u8",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:Yr}],methods:[],template:null},slot:150});const ou=new Uint8Array([]),au=new Uint8Array([180,30,16,0]),cu=new Uint8Array([176,30,16,0]),mu=new Uint8Array([15,32,16,0]),uu=new Uint8Array([85,110,99,104,101,99,107,32,116,111,32,117,110,114,111,108,108,32,116,104,101,32,99,105,114,99,117,108,97,114,32,97,110,110,117,108,97,114,32,111,102,32,116,104,101,32,105,109,97,103,101,46,0]);Object.assign(Zr,{...o,type:2,name:'struct{comptime type: type = bool, comptime defaultValue: bool = true, comptime description: *const [52:0]u8 = "Uncheck to unroll the circular annular of the image."}',length:1,byteSize:0,align:0,instance:{members:[{...s,type:7,isRequired:!1,name:"type",structure:D},{...s,type:8,isRequired:!1,slot:0,name:"defaultValue",structure:X},{...s,type:8,isRequired:!1,slot:1,name:"description",structure:Et}],methods:[],template:{memory:{array:ou},slots:{0:{structure:X,memory:{array:au},slots:{0:{structure:D,memory:{array:Ss},address:1056436}}},1:{structure:Et,memory:{array:cu},slots:{0:{structure:Yr,memory:{array:mu},address:1056432,slots:{0:{structure:Xr,memory:{array:uu},address:1056783}}}}}}}},slot:74});Object.assign(Tt,{...o,type:11,name:'*const struct{comptime type: type = bool, comptime defaultValue: bool = true, comptime description: *const [52:0]u8 = "Uncheck to unroll the circular annular of the image."}',length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:Zr}],methods:[],template:null},slot:73});Object.assign(Jr,{...o,type:1,name:"[72:0]u8",length:72,byteSize:73,align:0,instance:{members:[{...s,type:3,isRequired:!1,bitSize:8,byteSize:1,structure:k}],methods:[],template:null},slot:155});Object.assign(Qr,{...o,type:11,name:"*const [72:0]u8",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:Jr}],methods:[],template:null},slot:154});Object.assign(Ct,{...o,type:11,name:"*const *const [72:0]u8",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:Qr}],methods:[],template:null},slot:153});const lu=new Uint8Array([]),pu=new Uint8Array([144,30,16,0]),Xi=new Uint8Array([0]),yu=new Uint8Array([172,30,16,0]),fu=new Uint8Array([198,31,16,0]),du=new Uint8Array([65,117,116,111,109,97,116,105,99,97,108,108,121,32,115,101,116,32,116,104,101,32,105,100,101,97,108,32,112,101,114,105,111,100,105,99,105,116,121,32,102,111,114,32,116,104,101,32,99,117,114,114,101,110,116,32,114,97,100,105,117,115,32,115,101,116,116,105,110,103,115,46,0]);Object.assign(es,{...o,type:2,name:'struct{comptime type: type = bool, comptime defaultValue: bool = false, comptime description: *const [72:0]u8 = "Automatically set the ideal periodicity for the current radius settings."}',length:1,byteSize:0,align:0,instance:{members:[{...s,type:7,isRequired:!1,name:"type",structure:D},{...s,type:8,isRequired:!1,slot:0,name:"defaultValue",structure:X},{...s,type:8,isRequired:!1,slot:1,name:"description",structure:Ct}],methods:[],template:{memory:{array:lu},slots:{0:{structure:X,memory:{array:pu},slots:{0:{structure:D,memory:{array:Xi},address:1056400}}},1:{structure:Ct,memory:{array:yu},slots:{0:{structure:Qr,memory:{array:fu},address:1056428,slots:{0:{structure:Jr,memory:{array:du},address:1056710}}}}}}}},slot:76});Object.assign($t,{...o,type:11,name:'*const struct{comptime type: type = bool, comptime defaultValue: bool = false, comptime description: *const [72:0]u8 = "Automatically set the ideal periodicity for the current radius settings."}',length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:es}],methods:[],template:null},slot:75});Object.assign(ts,{...o,type:1,name:"[14:0]u8",length:14,byteSize:15,align:0,instance:{members:[{...s,type:3,isRequired:!1,bitSize:8,byteSize:1,structure:k}],methods:[],template:null},slot:158});Object.assign(rs,{...o,type:11,name:"*const [14:0]u8",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:ts}],methods:[],template:null},slot:157});Object.assign(kt,{...o,type:11,name:"*const *const [14:0]u8",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:rs}],methods:[],template:null},slot:156});const bu=new Uint8Array([]),hu=new Uint8Array([160,30,16,0]),gu=new Uint8Array([152,30,16,0]),Su=new Uint8Array([88,30,16,0]),wu=new Uint8Array([168,30,16,0]),Vu=new Uint8Array([183,31,16,0]),zu=new Uint8Array([80,111,108,97,114,32,114,111,116,97,116,105,111,110,0]);Object.assign(ss,{...o,type:2,name:'struct{comptime type: type = f32, comptime minValue: comptime_float = -360, comptime maxValue: comptime_float = 360, comptime defaultValue: comptime_float = 0, comptime description: *const [14:0]u8 = "Polar rotation"}',length:1,byteSize:0,align:0,instance:{members:[{...s,type:7,isRequired:!1,name:"type",structure:N},{...s,type:8,isRequired:!1,slot:0,name:"minValue",structure:S},{...s,type:8,isRequired:!1,slot:1,name:"maxValue",structure:S},{...s,type:8,isRequired:!1,slot:2,name:"defaultValue",structure:S},{...s,type:8,isRequired:!1,slot:3,name:"description",structure:kt}],methods:[],template:{memory:{array:bu},slots:{0:{structure:S,memory:{array:hu},slots:{0:{structure:j,memory:{array:Ks},address:1056416}}},1:{structure:S,memory:{array:gu},slots:{0:{structure:j,memory:{array:Gs},address:1056408}}},2:{structure:S,memory:{array:Su},slots:{0:{structure:j,memory:{array:G},address:1056344}}},3:{structure:kt,memory:{array:wu},slots:{0:{structure:rs,memory:{array:Vu},address:1056424,slots:{0:{structure:ts,memory:{array:zu},address:1056695}}}}}}}},slot:78});Object.assign(Dt,{...o,type:11,name:'*const struct{comptime type: type = f32, comptime minValue: comptime_float = -360, comptime maxValue: comptime_float = 360, comptime defaultValue: comptime_float = 0, comptime description: *const [14:0]u8 = "Polar rotation"}',length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:ss}],methods:[],template:null},slot:77});Object.assign(is,{...o,type:1,name:"[49:0]u8",length:49,byteSize:50,align:0,instance:{members:[{...s,type:3,isRequired:!1,bitSize:8,byteSize:1,structure:k}],methods:[],template:null},slot:161});Object.assign(ns,{...o,type:11,name:"*const [49:0]u8",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:is}],methods:[],template:null},slot:160});Object.assign(Bt,{...o,type:11,name:"*const *const [49:0]u8",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:ns}],methods:[],template:null},slot:159});const Ou=new Uint8Array([]),Au=new Uint8Array([160,30,16,0]),_u=new Uint8Array([152,30,16,0]),Ru=new Uint8Array([88,30,16,0]),qu=new Uint8Array([148,30,16,0]),Uu=new Uint8Array([133,31,16,0]),ju=new Uint8Array([83,112,105,110,32,109,97,112,112,101,100,32,105,109,97,103,101,46,32,66,101,115,116,32,117,115,101,100,32,119,105,116,104,32,112,111,108,97,114,32,114,111,116,97,116,105,111,110,46,0]);Object.assign(os,{...o,type:2,name:'struct{comptime type: type = f32, comptime minValue: comptime_float = -360, comptime maxValue: comptime_float = 360, comptime defaultValue: comptime_float = 0, comptime description: *const [49:0]u8 = "Spin mapped image. Best used with polar rotation."}',length:1,byteSize:0,align:0,instance:{members:[{...s,type:7,isRequired:!1,name:"type",structure:N},{...s,type:8,isRequired:!1,slot:0,name:"minValue",structure:S},{...s,type:8,isRequired:!1,slot:1,name:"maxValue",structure:S},{...s,type:8,isRequired:!1,slot:2,name:"defaultValue",structure:S},{...s,type:8,isRequired:!1,slot:3,name:"description",structure:Bt}],methods:[],template:{memory:{array:Ou},slots:{0:{structure:S,memory:{array:Au},slots:{0:{structure:j,memory:{array:Ks},address:1056416}}},1:{structure:S,memory:{array:_u},slots:{0:{structure:j,memory:{array:Gs},address:1056408}}},2:{structure:S,memory:{array:Ru},slots:{0:{structure:j,memory:{array:G},address:1056344}}},3:{structure:Bt,memory:{array:qu},slots:{0:{structure:ns,memory:{array:Uu},address:1056404,slots:{0:{structure:is,memory:{array:ju},address:1056645}}}}}}}},slot:80});Object.assign(Mt,{...o,type:11,name:'*const struct{comptime type: type = f32, comptime minValue: comptime_float = -360, comptime maxValue: comptime_float = 360, comptime defaultValue: comptime_float = 0, comptime description: *const [49:0]u8 = "Spin mapped image. Best used with polar rotation."}',length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:os}],methods:[],template:null},slot:79});const Pu=new Uint8Array([]),xu=new Uint8Array([144,30,16,0]),vu=new Uint8Array([140,30,16,0]),Iu=new Uint8Array([105,31,16,0]),Eu=new Uint8Array([69,110,97,98,108,101,32,104,121,112,101,114,32,100,114,111,115,116,101,32,101,102,102,101,99,116,46,0]);Object.assign(as,{...o,type:2,name:'struct{comptime type: type = bool, comptime defaultValue: bool = false, comptime description: *const [27:0]u8 = "Enable hyper droste effect."}',length:1,byteSize:0,align:0,instance:{members:[{...s,type:7,isRequired:!1,name:"type",structure:D},{...s,type:8,isRequired:!1,slot:0,name:"defaultValue",structure:X},{...s,type:8,isRequired:!1,slot:1,name:"description",structure:Se}],methods:[],template:{memory:{array:Pu},slots:{0:{structure:X,memory:{array:xu},slots:{0:{structure:D,memory:{array:Xi},address:1056400}}},1:{structure:Se,memory:{array:vu},slots:{0:{structure:De,memory:{array:Iu},address:1056396,slots:{0:{structure:ke,memory:{array:Eu},address:1056617}}}}}}}},slot:82});Object.assign(Nt,{...o,type:11,name:'*const struct{comptime type: type = bool, comptime defaultValue: bool = false, comptime description: *const [27:0]u8 = "Enable hyper droste effect."}',length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:as}],methods:[],template:null},slot:81});Object.assign(cs,{...o,type:1,name:"[28:0]u8",length:28,byteSize:29,align:0,instance:{members:[{...s,type:3,isRequired:!1,bitSize:8,byteSize:1,structure:k}],methods:[],template:null},slot:164});Object.assign(ms,{...o,type:11,name:"*const [28:0]u8",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:cs}],methods:[],template:null},slot:163});Object.assign(Lt,{...o,type:11,name:"*const *const [28:0]u8",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:ms}],methods:[],template:null},slot:162});const Tu=new Uint8Array([]),Cu=new Uint8Array([132,30,16,0]),gi=new Uint8Array([0,0,0,0]),$u=new Uint8Array([136,30,16,0]),ku=new Uint8Array([10,0,0,0]),Du=new Uint8Array([132,30,16,0]),Bu=new Uint8Array([128,30,16,0]),Mu=new Uint8Array([76,31,16,0]),Nu=new Uint8Array([85,115,101,100,32,98,121,32,104,121,112,101,114,32,100,114,111,115,116,101,32,111,112,116,105,111,110,46,0]);Object.assign(us,{...o,type:2,name:'struct{comptime type: type = i32, comptime minValue: comptime_int = 0, comptime maxValue: comptime_int = 10, comptime defaultValue: comptime_int = 0, comptime description: *const [28:0]u8 = "Used by hyper droste option."}',length:1,byteSize:0,align:0,instance:{members:[{...s,type:7,isRequired:!1,name:"type",structure:U},{...s,type:8,isRequired:!1,slot:0,name:"minValue",structure:R},{...s,type:8,isRequired:!1,slot:1,name:"maxValue",structure:R},{...s,type:8,isRequired:!1,slot:2,name:"defaultValue",structure:R},{...s,type:8,isRequired:!1,slot:3,name:"description",structure:Lt}],methods:[],template:{memory:{array:Tu},slots:{0:{structure:R,memory:{array:Cu},slots:{0:{structure:U,memory:{array:gi},address:1056388}}},1:{structure:R,memory:{array:$u},slots:{0:{structure:U,memory:{array:ku},address:1056392}}},2:{structure:R,memory:{array:Du},slots:{0:{structure:U,memory:{array:gi},address:1056388}}},3:{structure:Lt,memory:{array:Bu},slots:{0:{structure:ms,memory:{array:Mu},address:1056384,slots:{0:{structure:cs,memory:{array:Nu},address:1056588}}}}}}}},slot:84});Object.assign(Ft,{...o,type:11,name:'*const struct{comptime type: type = i32, comptime minValue: comptime_int = 0, comptime maxValue: comptime_int = 10, comptime defaultValue: comptime_int = 0, comptime description: *const [28:0]u8 = "Used by hyper droste option."}',length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:us}],methods:[],template:null},slot:83});const Lu=new Uint8Array([]),Fu=new Uint8Array([170,170,170,170]),Ku=new Uint8Array([170,170,170,170]),Gu=new Uint8Array([170,170,170,170]),Wu=new Uint8Array([170,170,170,170]),Hu=new Uint8Array([170,170,170,170]),Xu=new Uint8Array([170,170,170,170]),Yu=new Uint8Array([170,170,170,170]),Zu=new Uint8Array([170,170,170,170]),Ju=new Uint8Array([170,170,170,170]),Qu=new Uint8Array([170,170,170,170]),el=new Uint8Array([170,170,170,170]),tl=new Uint8Array([170,170,170,170]),rl=new Uint8Array([170,170,170,170]),sl=new Uint8Array([170,170,170,170]),il=new Uint8Array([170,170,170,170]),nl=new Uint8Array([170,170,170,170]),ol=new Uint8Array([170,170,170,170]),al=new Uint8Array([170,170,170,170]),cl=new Uint8Array([170,170,170,170]),ml=new Uint8Array([170,170,170,170]),ul=new Uint8Array([170,170,170,170]),ll=new Uint8Array([170,170,170,170]);Object.assign(ls,{...o,type:2,name:'struct{comptime size: struct{comptime type: type = @Vector(2, i32), comptime minValue: struct{comptime comptime_int = 100, comptime comptime_int = 100} = .{100, 100}, comptime maxValue: struct{comptime comptime_int = 4000, comptime comptime_int = 4000} = .{4000, 4000}, comptime defaultValue: struct{comptime comptime_int = 680, comptime comptime_int = 680} = .{680, 680}, comptime description: *const [26:0]u8 = "Output size of final image"} = .{.type = @Vector(2, i32), .minValue = .{100, 100}, .maxValue = .{4000, 4000}, .defaultValue = .{680, 680}, .description = "Output size of final image"}, comptime radiusInside: struct{comptime type: type = f32, comptime minValue: comptime_float = 0.1, comptime maxValue: comptime_float = 100, comptime defaultValue: comptime_float = 25, comptime description: *const [41:0]u8 = "The inner radius of the repeating annular"} = .{.type = f32, .minValue = 0.1, .maxValue = 100, .defaultValue = 25, .description = "The inner radius of the repeating annular"}, comptime radiusOutside: struct{comptime type: type = f32, comptime minValue: comptime_float = 1, comptime maxValue: comptime_float = 100, comptime defaultValue: comptime_float = 100, comptime description: *const [41:0]u8 = "The outer radius of the repeating annular"} = .{.type = f32, .minValue = 1, .maxValue = 100, .defaultValue = 100, .description = "The outer radius of the repeating annular"}, comptime periodicity: struct{comptime type: type = f32, comptime minValue: comptime_float = -6, comptime maxValue: comptime_float = 6, comptime defaultValue: comptime_float = 1, comptime description: *const [55:0]u8 = "The number of image the image is repeated on each level"} = .{.type = f32, .minValue = -6, .maxValue = 6, .defaultValue = 1, .description = "The number of image the image is repeated on each level"}, comptime strands: struct{comptime type: type = i32, comptime minValue: comptime_int = -12, comptime maxValue: comptime_int = 12, comptime defaultValue: comptime_int = 1, comptime description: *const [35:0]u8 = "The number of strands of the spiral"} = .{.type = i32, .minValue = -12, .maxValue = 12, .defaultValue = 1, .description = "The number of strands of the spiral"}, comptime strandMirror: struct{comptime type: type = bool, comptime defaultValue: bool = true, comptime description: *const [50:0]u8 = "Smoother repeating when using more than one strand"} = .{.type = bool, .defaultValue = true, .description = "Smoother repeating when using more than one strand"}, comptime zoom: struct{comptime type: type = f32, comptime minValue: comptime_float = 0, comptime maxValue: comptime_float = 30, comptime defaultValue: comptime_float = 0, comptime description: *const [27:0]u8 = "Overall image magnification"} = .{.type = f32, .minValue = 0, .maxValue = 30, .defaultValue = 0, .description = "Overall image magnification"}, comptime rotate: struct{comptime type: type = f32, comptime minValue: comptime_float = -360, comptime maxValue: comptime_float = 360, comptime defaultValue: comptime_float = 0, comptime description: *const [22:0]u8 = "Overall image rotation"} = .{.type = f32, .minValue = -360, .maxValue = 360, .defaultValue = 0, .description = "Overall image rotation"}, comptime antialiasing: struct{comptime type: type = i32, comptime minValue: comptime_int = 1, comptime maxValue: comptime_int = 3, comptime defaultValue: comptime_int = 1, comptime description: *const [60:0]u8 = "Super sampling quality. Number of samples squared per pixel."} = .{.type = i32, .minValue = 1, .maxValue = 3, .defaultValue = 1, .description = "Super sampling quality. Number of samples squared per pixel."}, comptime center: struct{comptime type: type = @Vector(2, f32), comptime minValue: struct{comptime comptime_float = -200, comptime comptime_float = -200} = .{-200, -200}, comptime maxValue: struct{comptime comptime_float = 200, comptime comptime_float = 200} = .{200, 200}, comptime defaultValue: struct{comptime comptime_float = 0, comptime comptime_float = 0} = .{0, 0}, comptime description: *const [40:0]u8 = "Panning of the image in the output frame"} = .{.type = @Vector(2, f32), .minValue = .{-200, -200}, .maxValue = .{200, 200}, .defaultValue = .{0, 0}, .description = "Panning of the image in the output frame"}, comptime centerShift: struct{comptime type: type = @Vector(2, f32), comptime minValue: struct{comptime comptime_float = -200, comptime comptime_float = -200} = .{-200, -200}, comptime maxValue: struct{comptime comptime_float = 200, comptime comptime_float = 200} = .{200, 200}, comptime defaultValue: struct{comptime comptime_float = 0, comptime comptime_float = 0} = .{0, 0}, comptime description: *const [30:0]u8 = "Shift the centre of the spiral"} = .{.type = @Vector(2, f32), .minValue = .{-200, -200}, .maxValue = .{200, 200}, .defaultValue = .{0, 0}, .description = "Shift the centre of the spiral"}, comptime backgroundRGBA: struct{comptime type: type = @Vector(4, f32), comptime minValue: struct{comptime comptime_float = 0, comptime comptime_float = 0, comptime comptime_float = 0, comptime comptime_float = 0} = .{0, 0, 0, 0}, comptime maxValue: struct{comptime comptime_float = 1, comptime comptime_float = 1, comptime comptime_float = 1, comptime comptime_float = 1} = .{1, 1, 1, 1}, comptime defaultValue: struct{comptime comptime_float = 0, comptime comptime_float = 0, comptime comptime_float = 0, comptime comptime_float = 1} = .{0, 0, 0, 1}, comptime description: *const [30:0]u8 = "Set the RGBA background colour"} = .{.type = @Vector(4, f32), .minValue = .{0, 0, 0, 0}, .maxValue = .{1, 1, 1, 1}, .defaultValue = .{0, 0, 0, 1}, .description = "Set the RGBA background colour"}, comptime levels: struct{comptime type: type = i32, comptime minValue: comptime_int = 1, comptime maxValue: comptime_int = 20, comptime defaultValue: comptime_int = 9, comptime description: *const [44:0]u8 = "The number of repeating levels of the spiral"} = .{.type = i32, .minValue = 1, .maxValue = 20, .defaultValue = 9, .description = "The number of repeating levels of the spiral"}, comptime levelStart: struct{comptime type: type = i32, comptime minValue: comptime_int = 1, comptime maxValue: comptime_int = 20, comptime defaultValue: comptime_int = 3, comptime description: *const [25:0]u8 = "The starting spiral level"} = .{.type = i32, .minValue = 1, .maxValue = 20, .defaultValue = 3, .description = "The starting spiral level"}, comptime transparentInside: struct{comptime type: type = bool, comptime defaultValue: bool = true, comptime description: *const [74:0]u8 = "Enable for images with transparent middle areas (such as a picture frame)."} = .{.type = bool, .defaultValue = true, .description = "Enable for images with transparent middle areas (such as a picture frame)."}, comptime transparentOutside: struct{comptime type: type = bool, comptime defaultValue: bool = true, comptime description: *const [60:0]u8 = "Enable for images with transparent areas around the outside."} = .{.type = bool, .defaultValue = true, .description = "Enable for images with transparent areas around the outside."}, comptime twist: struct{comptime type: type = bool, comptime defaultValue: bool = true, comptime description: *const [52:0]u8 = "Uncheck to unroll the circular annular of the image."} = .{.type = bool, .defaultValue = true, .description = "Uncheck to unroll the circular annular of the image."}, comptime periodicityAuto: struct{comptime type: type = bool, comptime defaultValue: bool = false, comptime description: *const [72:0]u8 = "Automatically set the ideal periodicity for the current radius settings."} = .{.type = bool, .defaultValue = false, .description = "Automatically set the ideal periodicity for the current radius settings."}, comptime rotatePolar: struct{comptime type: type = f32, comptime minValue: comptime_float = -360, comptime maxValue: comptime_float = 360, comptime defaultValue: comptime_float = 0, comptime description: *const [14:0]u8 = "Polar rotation"} = .{.type = f32, .minValue = -360, .maxValue = 360, .defaultValue = 0, .description = "Polar rotation"}, comptime rotateSpin: struct{comptime type: type = f32, comptime minValue: comptime_float = -360, comptime maxValue: comptime_float = 360, comptime defaultValue: comptime_float = 0, comptime description: *const [49:0]u8 = "Spin mapped image. Best used with polar rotation."} = .{.type = f32, .minValue = -360, .maxValue = 360, .defaultValue = 0, .description = "Spin mapped image. Best used with polar rotation."}, comptime hyperDroste: struct{comptime type: type = bool, comptime defaultValue: bool = false, comptime description: *const [27:0]u8 = "Enable hyper droste effect."} = .{.type = bool, .defaultValue = false, .description = "Enable hyper droste effect."}, comptime fractalPoints: struct{comptime type: type = i32, comptime minValue: comptime_int = 0, comptime maxValue: comptime_int = 10, comptime defaultValue: comptime_int = 0, comptime description: *const [28:0]u8 = "Used by hyper droste option."} = .{.type = i32, .minValue = 0, .maxValue = 10, .defaultValue = 0, .description = "Used by hyper droste option."}}',length:1,byteSize:0,align:0,instance:{members:[{...s,type:8,isRequired:!1,slot:0,name:"size",structure:at},{...s,type:8,isRequired:!1,slot:1,name:"radiusInside",structure:ct},{...s,type:8,isRequired:!1,slot:2,name:"radiusOutside",structure:mt},{...s,type:8,isRequired:!1,slot:3,name:"periodicity",structure:lt},{...s,type:8,isRequired:!1,slot:4,name:"strands",structure:yt},{...s,type:8,isRequired:!1,slot:5,name:"strandMirror",structure:dt},{...s,type:8,isRequired:!1,slot:6,name:"zoom",structure:bt},{...s,type:8,isRequired:!1,slot:7,name:"rotate",structure:gt},{...s,type:8,isRequired:!1,slot:8,name:"antialiasing",structure:St},{...s,type:8,isRequired:!1,slot:9,name:"center",structure:Vt},{...s,type:8,isRequired:!1,slot:10,name:"centerShift",structure:zt},{...s,type:8,isRequired:!1,slot:11,name:"backgroundRGBA",structure:Rt},{...s,type:8,isRequired:!1,slot:12,name:"levels",structure:Ut},{...s,type:8,isRequired:!1,slot:13,name:"levelStart",structure:Pt},{...s,type:8,isRequired:!1,slot:14,name:"transparentInside",structure:vt},{...s,type:8,isRequired:!1,slot:15,name:"transparentOutside",structure:It},{...s,type:8,isRequired:!1,slot:16,name:"twist",structure:Tt},{...s,type:8,isRequired:!1,slot:17,name:"periodicityAuto",structure:$t},{...s,type:8,isRequired:!1,slot:18,name:"rotatePolar",structure:Dt},{...s,type:8,isRequired:!1,slot:19,name:"rotateSpin",structure:Mt},{...s,type:8,isRequired:!1,slot:20,name:"hyperDroste",structure:Nt},{...s,type:8,isRequired:!1,slot:21,name:"fractalPoints",structure:Ft}],methods:[],template:{memory:{array:Lu},slots:{0:{structure:at,memory:{array:Fu},slots:{0:{structure:fr,memory:{array:P},address:-1431655766}}},1:{structure:ct,memory:{array:Ku},slots:{0:{structure:dr,memory:{array:P},address:-1431655766}}},2:{structure:mt,memory:{array:Gu},slots:{0:{structure:br,memory:{array:P},address:-1431655766}}},3:{structure:lt,memory:{array:Wu},slots:{0:{structure:Sr,memory:{array:P},address:-1431655766}}},4:{structure:yt,memory:{array:Hu},slots:{0:{structure:zr,memory:{array:P},address:-1431655766}}},5:{structure:dt,memory:{array:Xu},slots:{0:{structure:_r,memory:{array:P},address:-1431655766}}},6:{structure:bt,memory:{array:Yu},slots:{0:{structure:Rr,memory:{array:P},address:-1431655766}}},7:{structure:gt,memory:{array:Zu},slots:{0:{structure:jr,memory:{array:P},address:-1431655766}}},8:{structure:St,memory:{array:Ju},slots:{0:{structure:Pr,memory:{array:P},address:-1431655766}}},9:{structure:Vt,memory:{array:Qu},slots:{0:{structure:Ir,memory:{array:P},address:-1431655766}}},10:{structure:zt,memory:{array:el},slots:{0:{structure:Er,memory:{array:P},address:-1431655766}}},11:{structure:Rt,memory:{array:tl},slots:{0:{structure:kr,memory:{array:P},address:-1431655766}}},12:{structure:Ut,memory:{array:rl},slots:{0:{structure:Mr,memory:{array:P},address:-1431655766}}},13:{structure:Pt,memory:{array:sl},slots:{0:{structure:Fr,memory:{array:P},address:-1431655766}}},14:{structure:vt,memory:{array:il},slots:{0:{structure:Wr,memory:{array:P},address:-1431655766}}},15:{structure:It,memory:{array:nl},slots:{0:{structure:Hr,memory:{array:P},address:-1431655766}}},16:{structure:Tt,memory:{array:ol},slots:{0:{structure:Zr,memory:{array:P},address:-1431655766}}},17:{structure:$t,memory:{array:al},slots:{0:{structure:es,memory:{array:P},address:-1431655766}}},18:{structure:Dt,memory:{array:cl},slots:{0:{structure:ss,memory:{array:P},address:-1431655766}}},19:{structure:Mt,memory:{array:ml},slots:{0:{structure:os,memory:{array:P},address:-1431655766}}},20:{structure:Nt,memory:{array:ul},slots:{0:{structure:as,memory:{array:P},address:-1431655766}}},21:{structure:Ft,memory:{array:ll},slots:{0:{structure:us,memory:{array:P},address:-1431655766}}}}}},slot:15});Object.assign(Kt,{...o,type:11,name:'*struct{comptime size: struct{comptime type: type = @Vector(2, i32), comptime minValue: struct{comptime comptime_int = 100, comptime comptime_int = 100} = .{100, 100}, comptime maxValue: struct{comptime comptime_int = 4000, comptime comptime_int = 4000} = .{4000, 4000}, comptime defaultValue: struct{comptime comptime_int = 680, comptime comptime_int = 680} = .{680, 680}, comptime description: *const [26:0]u8 = "Output size of final image"} = .{.type = @Vector(2, i32), .minValue = .{100, 100}, .maxValue = .{4000, 4000}, .defaultValue = .{680, 680}, .description = "Output size of final image"}, comptime radiusInside: struct{comptime type: type = f32, comptime minValue: comptime_float = 0.1, comptime maxValue: comptime_float = 100, comptime defaultValue: comptime_float = 25, comptime description: *const [41:0]u8 = "The inner radius of the repeating annular"} = .{.type = f32, .minValue = 0.1, .maxValue = 100, .defaultValue = 25, .description = "The inner radius of the repeating annular"}, comptime radiusOutside: struct{comptime type: type = f32, comptime minValue: comptime_float = 1, comptime maxValue: comptime_float = 100, comptime defaultValue: comptime_float = 100, comptime description: *const [41:0]u8 = "The outer radius of the repeating annular"} = .{.type = f32, .minValue = 1, .maxValue = 100, .defaultValue = 100, .description = "The outer radius of the repeating annular"}, comptime periodicity: struct{comptime type: type = f32, comptime minValue: comptime_float = -6, comptime maxValue: comptime_float = 6, comptime defaultValue: comptime_float = 1, comptime description: *const [55:0]u8 = "The number of image the image is repeated on each level"} = .{.type = f32, .minValue = -6, .maxValue = 6, .defaultValue = 1, .description = "The number of image the image is repeated on each level"}, comptime strands: struct{comptime type: type = i32, comptime minValue: comptime_int = -12, comptime maxValue: comptime_int = 12, comptime defaultValue: comptime_int = 1, comptime description: *const [35:0]u8 = "The number of strands of the spiral"} = .{.type = i32, .minValue = -12, .maxValue = 12, .defaultValue = 1, .description = "The number of strands of the spiral"}, comptime strandMirror: struct{comptime type: type = bool, comptime defaultValue: bool = true, comptime description: *const [50:0]u8 = "Smoother repeating when using more than one strand"} = .{.type = bool, .defaultValue = true, .description = "Smoother repeating when using more than one strand"}, comptime zoom: struct{comptime type: type = f32, comptime minValue: comptime_float = 0, comptime maxValue: comptime_float = 30, comptime defaultValue: comptime_float = 0, comptime description: *const [27:0]u8 = "Overall image magnification"} = .{.type = f32, .minValue = 0, .maxValue = 30, .defaultValue = 0, .description = "Overall image magnification"}, comptime rotate: struct{comptime type: type = f32, comptime minValue: comptime_float = -360, comptime maxValue: comptime_float = 360, comptime defaultValue: comptime_float = 0, comptime description: *const [22:0]u8 = "Overall image rotation"} = .{.type = f32, .minValue = -360, .maxValue = 360, .defaultValue = 0, .description = "Overall image rotation"}, comptime antialiasing: struct{comptime type: type = i32, comptime minValue: comptime_int = 1, comptime maxValue: comptime_int = 3, comptime defaultValue: comptime_int = 1, comptime description: *const [60:0]u8 = "Super sampling quality. Number of samples squared per pixel."} = .{.type = i32, .minValue = 1, .maxValue = 3, .defaultValue = 1, .description = "Super sampling quality. Number of samples squared per pixel."}, comptime center: struct{comptime type: type = @Vector(2, f32), comptime minValue: struct{comptime comptime_float = -200, comptime comptime_float = -200} = .{-200, -200}, comptime maxValue: struct{comptime comptime_float = 200, comptime comptime_float = 200} = .{200, 200}, comptime defaultValue: struct{comptime comptime_float = 0, comptime comptime_float = 0} = .{0, 0}, comptime description: *const [40:0]u8 = "Panning of the image in the output frame"} = .{.type = @Vector(2, f32), .minValue = .{-200, -200}, .maxValue = .{200, 200}, .defaultValue = .{0, 0}, .description = "Panning of the image in the output frame"}, comptime centerShift: struct{comptime type: type = @Vector(2, f32), comptime minValue: struct{comptime comptime_float = -200, comptime comptime_float = -200} = .{-200, -200}, comptime maxValue: struct{comptime comptime_float = 200, comptime comptime_float = 200} = .{200, 200}, comptime defaultValue: struct{comptime comptime_float = 0, comptime comptime_float = 0} = .{0, 0}, comptime description: *const [30:0]u8 = "Shift the centre of the spiral"} = .{.type = @Vector(2, f32), .minValue = .{-200, -200}, .maxValue = .{200, 200}, .defaultValue = .{0, 0}, .description = "Shift the centre of the spiral"}, comptime backgroundRGBA: struct{comptime type: type = @Vector(4, f32), comptime minValue: struct{comptime comptime_float = 0, comptime comptime_float = 0, comptime comptime_float = 0, comptime comptime_float = 0} = .{0, 0, 0, 0}, comptime maxValue: struct{comptime comptime_float = 1, comptime comptime_float = 1, comptime comptime_float = 1, comptime comptime_float = 1} = .{1, 1, 1, 1}, comptime defaultValue: struct{comptime comptime_float = 0, comptime comptime_float = 0, comptime comptime_float = 0, comptime comptime_float = 1} = .{0, 0, 0, 1}, comptime description: *const [30:0]u8 = "Set the RGBA background colour"} = .{.type = @Vector(4, f32), .minValue = .{0, 0, 0, 0}, .maxValue = .{1, 1, 1, 1}, .defaultValue = .{0, 0, 0, 1}, .description = "Set the RGBA background colour"}, comptime levels: struct{comptime type: type = i32, comptime minValue: comptime_int = 1, comptime maxValue: comptime_int = 20, comptime defaultValue: comptime_int = 9, comptime description: *const [44:0]u8 = "The number of repeating levels of the spiral"} = .{.type = i32, .minValue = 1, .maxValue = 20, .defaultValue = 9, .description = "The number of repeating levels of the spiral"}, comptime levelStart: struct{comptime type: type = i32, comptime minValue: comptime_int = 1, comptime maxValue: comptime_int = 20, comptime defaultValue: comptime_int = 3, comptime description: *const [25:0]u8 = "The starting spiral level"} = .{.type = i32, .minValue = 1, .maxValue = 20, .defaultValue = 3, .description = "The starting spiral level"}, comptime transparentInside: struct{comptime type: type = bool, comptime defaultValue: bool = true, comptime description: *const [74:0]u8 = "Enable for images with transparent middle areas (such as a picture frame)."} = .{.type = bool, .defaultValue = true, .description = "Enable for images with transparent middle areas (such as a picture frame)."}, comptime transparentOutside: struct{comptime type: type = bool, comptime defaultValue: bool = true, comptime description: *const [60:0]u8 = "Enable for images with transparent areas around the outside."} = .{.type = bool, .defaultValue = true, .description = "Enable for images with transparent areas around the outside."}, comptime twist: struct{comptime type: type = bool, comptime defaultValue: bool = true, comptime description: *const [52:0]u8 = "Uncheck to unroll the circular annular of the image."} = .{.type = bool, .defaultValue = true, .description = "Uncheck to unroll the circular annular of the image."}, comptime periodicityAuto: struct{comptime type: type = bool, comptime defaultValue: bool = false, comptime description: *const [72:0]u8 = "Automatically set the ideal periodicity for the current radius settings."} = .{.type = bool, .defaultValue = false, .description = "Automatically set the ideal periodicity for the current radius settings."}, comptime rotatePolar: struct{comptime type: type = f32, comptime minValue: comptime_float = -360, comptime maxValue: comptime_float = 360, comptime defaultValue: comptime_float = 0, comptime description: *const [14:0]u8 = "Polar rotation"} = .{.type = f32, .minValue = -360, .maxValue = 360, .defaultValue = 0, .description = "Polar rotation"}, comptime rotateSpin: struct{comptime type: type = f32, comptime minValue: comptime_float = -360, comptime maxValue: comptime_float = 360, comptime defaultValue: comptime_float = 0, comptime description: *const [49:0]u8 = "Spin mapped image. Best used with polar rotation."} = .{.type = f32, .minValue = -360, .maxValue = 360, .defaultValue = 0, .description = "Spin mapped image. Best used with polar rotation."}, comptime hyperDroste: struct{comptime type: type = bool, comptime defaultValue: bool = false, comptime description: *const [27:0]u8 = "Enable hyper droste effect."} = .{.type = bool, .defaultValue = false, .description = "Enable hyper droste effect."}, comptime fractalPoints: struct{comptime type: type = i32, comptime minValue: comptime_int = 0, comptime maxValue: comptime_int = 10, comptime defaultValue: comptime_int = 0, comptime description: *const [28:0]u8 = "Used by hyper droste option."} = .{.type = i32, .minValue = 0, .maxValue = 10, .defaultValue = 0, .description = "Used by hyper droste option."}}',length:1,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:ls}],methods:[],template:null},slot:14});const pl=new Uint8Array([]),yl=new Uint8Array([124,30,16,0]),fl=new Uint8Array([4,0,0,0]);Object.assign(We,{...o,type:2,name:"struct{comptime channels: comptime_int = 4}",length:1,byteSize:0,align:0,instance:{members:[{...s,type:8,isRequired:!1,slot:0,name:"channels",structure:R}],methods:[],template:{memory:{array:pl},slots:{0:{structure:R,memory:{array:yl},slots:{0:{structure:U,memory:{array:fl},address:1056380}}}}}},slot:86});Object.assign(Re,{...o,type:11,name:"*const struct{comptime channels: comptime_int = 4}",length:1,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:We}],methods:[],template:null},slot:85});const dl=new Uint8Array([]),bl=new Uint8Array([170,170,170,170]);Object.assign(ps,{...o,type:2,name:"struct{comptime src: struct{comptime channels: comptime_int = 4} = .{.channels = 4}}",length:1,byteSize:0,align:0,instance:{members:[{...s,type:8,isRequired:!1,slot:0,name:"src",structure:Re}],methods:[],template:{memory:{array:dl},slots:{0:{structure:Re,memory:{array:bl},slots:{0:{structure:We,memory:{array:P},address:-1431655766}}}}}},slot:17});Object.assign(Gt,{...o,type:11,name:"*struct{comptime src: struct{comptime channels: comptime_int = 4} = .{.channels = 4}}",length:1,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:ps}],methods:[],template:null},slot:16});const hl=new Uint8Array([]),gl=new Uint8Array([170,170,170,170]);Object.assign(ys,{...o,type:2,name:"struct{comptime dst: struct{comptime channels: comptime_int = 4} = .{.channels = 4}}",length:1,byteSize:0,align:0,instance:{members:[{...s,type:8,isRequired:!1,slot:0,name:"dst",structure:Re}],methods:[],template:{memory:{array:hl},slots:{0:{structure:Re,memory:{array:gl},slots:{0:{structure:We,memory:{array:P},address:-1431655766}}}}}},slot:19});Object.assign(Wt,{...o,type:11,name:"*struct{comptime dst: struct{comptime channels: comptime_int = 4} = .{.channels = 4}}",length:1,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,slot:0,structure:ys}],methods:[],template:null},slot:18});const Sl=new Uint8Array([]),wl=new Uint8Array([]),Vl=new Uint8Array([44,251,15,0]),zl=new Uint8Array([73,171,16,0]),Ol=new Uint8Array([99,111,109,46,115,117,98,98,108,117,101,46,102,105,108,116,101,114,115,0]),Al=new Uint8Array([108,251,15,0]),_l=new Uint8Array([61,171,16,0]),Rl=new Uint8Array([84,111,109,32,66,101,100,100,97,114,100,0]),ql=new Uint8Array([172,251,15,0]),Ul=new Uint8Array([1,0,0,0]),jl=new Uint8Array([4,252,15,0]),Pl=new Uint8Array([42,171,16,0]),xl=new Uint8Array([84,104,101,32,68,114,111,115,116,101,32,101,102,102,101,99,116,46,0]),vl=new Uint8Array([170,170,170,170]),Il=new Uint8Array([170,170,170,170]),El=new Uint8Array([170,170,170,170]);Object.assign($s,{...o,type:2,name:"droste.kernel",length:1,byteSize:0,align:0,instance:{members:[],methods:[],template:{memory:{array:Sl}}},static:{members:[{...s,type:6,isRequired:!1,slot:0,name:"namespace",structure:et},{...s,type:6,isRequired:!1,slot:1,name:"vendor",structure:tt},{...s,type:6,isRequired:!1,slot:2,name:"version",structure:ae},{...s,type:6,isRequired:!1,slot:3,name:"description",structure:rt},{...s,type:6,isRequired:!1,slot:4,name:"parameters",structure:Kt},{...s,type:6,isRequired:!1,slot:5,name:"inputImages",structure:Gt},{...s,type:6,isRequired:!1,slot:6,name:"outputImages",structure:Wt}],methods:[],template:{memory:{array:wl},slots:{0:{structure:et,memory:{array:Vl},slots:{0:{structure:sr,memory:{array:zl},slots:{0:{structure:rr,memory:{array:Ol},address:1092425}}}}},1:{structure:tt,memory:{array:Al},slots:{0:{structure:nr,memory:{array:_l},slots:{0:{structure:ir,memory:{array:Rl},address:1092413}}}}},2:{structure:ae,memory:{array:ql},slots:{0:{structure:U,memory:{array:Ul}}}},3:{structure:rt,memory:{array:jl},slots:{0:{structure:ar,memory:{array:Pl},slots:{0:{structure:or,memory:{array:xl},address:1092394}}}}},4:{structure:Kt,memory:{array:vl},slots:{0:{structure:ls,memory:{array:P},address:-1431655766}}},5:{structure:Gt,memory:{array:Il},slots:{0:{structure:ps,memory:{array:P},address:-1431655766}}},6:{structure:Wt,memory:{array:El},slots:{0:{structure:ys,memory:{array:P},address:-1431655766}}}}}},slot:1});Object.assign(Pe,{...o,type:13,name:"@Vector(4, u8)",length:4,instance:{members:[{...s,type:3,isRequired:!1,bitSize:8,byteSize:1,structure:k}],methods:[],template:null},slot:24});Object.assign(fs,{...o,type:12,name:"[_]const @Vector(4, u8)",length:0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,structure:Pe}],methods:[],template:null},slot:23});Object.assign(ds,{...o,type:11,name:"[]const @Vector(4, u8)",length:1,byteSize:8,isConst:!0,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:64,byteSize:8,slot:0,structure:fs}],methods:[],template:null},slot:22});Object.assign(Y,{...o,name:"u32",length:1,instance:{members:[{...s,type:3,isRequired:!1,bitOffset:0,bitSize:32,byteSize:4,structure:Y}],methods:[],template:null},slot:25});const Tl=new Uint8Array([0,0,0,0,1,0,0,0]);Object.assign(bs,{...o,type:9,name:"droste.ColorSpace",length:1,byteSize:1,align:0,instance:{members:[{...s,type:2,isRequired:!1,bitSize:32,byteSize:4,name:"srgb",structure:U},{...s,type:2,isRequired:!1,bitSize:32,byteSize:4,name:"display-p3",structure:U}],methods:[],template:{memory:{array:Tl}}},slot:26});Object.assign(ve,{...o,name:"usize",length:1,instance:{members:[{...s,type:3,isRequired:!1,bitOffset:0,bitSize:32,byteSize:4,structure:ve}],methods:[],template:null},slot:28});const Cl=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]),$l=new Uint8Array([]),kl=new Uint8Array([8,250,15,0]),Dl=new Uint8Array([4,0,0,0]);Object.assign(Ht,{...o,type:2,name:"droste.Image(u8,4,false)",length:1,byteSize:24,hasPointer:!0,instance:{members:[{...s,type:6,bitOffset:0,bitSize:64,byteSize:8,slot:0,name:"data",structure:ds},{...s,type:3,bitOffset:64,bitSize:32,byteSize:4,slot:1,name:"width",structure:Y},{...s,type:3,bitOffset:96,bitSize:32,byteSize:4,slot:2,name:"height",structure:Y},{...s,type:5,isRequired:!1,bitOffset:160,bitSize:1,byteSize:1,slot:3,name:"colorSpace",structure:bs},{...s,type:1,isRequired:!1,bitOffset:168,bitSize:1,byteSize:1,slot:4,name:"premultiplied",structure:D},{...s,type:3,isRequired:!1,bitOffset:128,bitSize:32,byteSize:4,slot:5,name:"offset",structure:ve}],methods:[],template:{memory:{array:Cl}}},static:{members:[{...s,type:7,isRequired:!1,name:"Pixel",structure:Pe},{...s,type:7,isRequired:!1,name:"FPixel",structure:je},{...s,type:6,isRequired:!1,slot:0,name:"channels",structure:ae}],methods:[],template:{memory:{array:$l},slots:{0:{structure:ae,memory:{array:kl},slots:{0:{structure:U,memory:{array:Dl}}}}}}},slot:21});const Bl=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]),Ml=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]),Nl=new Uint8Array([0,0,0,0,0,0,0,0]),Ws=new Uint8Array([]);Object.assign(He,{...o,type:2,name:"droste.KernelInput(u8,droste.kernel)",length:1,byteSize:24,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitOffset:0,bitSize:192,byteSize:24,slot:0,name:"src",structure:Ht}],methods:[],template:{memory:{array:Bl},slots:{0:{structure:Ht,memory:{array:Ml},slots:{0:{structure:ds,memory:{array:Nl},slots:{0:{structure:fs,memory:{array:Ws}}}}}}}}},slot:20});Object.assign(hs,{...o,type:12,name:"[_]@Vector(4, u8)",length:0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:32,byteSize:4,structure:Pe}],methods:[],template:null},slot:23});Object.assign(gs,{...o,type:11,name:"[]@Vector(4, u8)",length:1,byteSize:8,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitSize:64,byteSize:8,slot:0,structure:hs}],methods:[],template:null},slot:31});const Ll=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]),Fl=new Uint8Array([]),Kl=new Uint8Array([8,250,15,0]),Gl=new Uint8Array([4,0,0,0]);Object.assign(Xt,{...o,type:2,name:"droste.Image(u8,4,true)",length:1,byteSize:24,hasPointer:!0,instance:{members:[{...s,type:6,bitOffset:0,bitSize:64,byteSize:8,slot:0,name:"data",structure:gs},{...s,type:3,bitOffset:64,bitSize:32,byteSize:4,slot:1,name:"width",structure:Y},{...s,type:3,bitOffset:96,bitSize:32,byteSize:4,slot:2,name:"height",structure:Y},{...s,type:5,isRequired:!1,bitOffset:160,bitSize:1,byteSize:1,slot:3,name:"colorSpace",structure:bs},{...s,type:1,isRequired:!1,bitOffset:168,bitSize:1,byteSize:1,slot:4,name:"premultiplied",structure:D},{...s,type:3,isRequired:!1,bitOffset:128,bitSize:32,byteSize:4,slot:5,name:"offset",structure:ve}],methods:[],template:{memory:{array:Ll}}},static:{members:[{...s,type:7,isRequired:!1,name:"Pixel",structure:Pe},{...s,type:7,isRequired:!1,name:"FPixel",structure:je},{...s,type:6,isRequired:!1,slot:0,name:"channels",structure:ae}],methods:[],template:{memory:{array:Fl},slots:{0:{structure:ae,memory:{array:Kl},slots:{0:{structure:U,memory:{array:Gl}}}}}}},slot:30});const Wl=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]),Hl=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]),Xl=new Uint8Array([0,0,0,0,0,0,0,0]);Object.assign(Xe,{...o,type:2,name:"droste.KernelOutput(u8,droste.kernel)",length:1,byteSize:24,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitOffset:0,bitSize:192,byteSize:24,slot:0,name:"dst",structure:Xt}],methods:[],template:{memory:{array:Wl},slots:{0:{structure:Xt,memory:{array:Hl},slots:{0:{structure:gs,memory:{array:Xl},slots:{0:{structure:hs,memory:{array:Ws}}}}}}}}},slot:29});const Yl=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,63,168,2,0,0,168,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,200,65,0,0,200,66,0,0,128,63,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,9,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0]);Object.assign(Ye,{...o,type:2,name:"droste.KernelParameters(droste.kernel)",length:1,byteSize:96,align:4,instance:{members:[{...s,type:6,isRequired:!1,bitOffset:128,bitSize:64,byteSize:8,slot:0,name:"size",structure:cr},{...s,type:4,isRequired:!1,bitOffset:320,bitSize:32,byteSize:4,slot:1,name:"radiusInside",structure:N},{...s,type:4,isRequired:!1,bitOffset:352,bitSize:32,byteSize:4,slot:2,name:"radiusOutside",structure:N},{...s,type:4,isRequired:!1,bitOffset:384,bitSize:32,byteSize:4,slot:3,name:"periodicity",structure:N},{...s,type:2,isRequired:!1,bitOffset:416,bitSize:32,byteSize:4,slot:4,name:"strands",structure:U},{...s,type:1,isRequired:!1,bitOffset:704,bitSize:1,byteSize:1,slot:5,name:"strandMirror",structure:D},{...s,type:4,isRequired:!1,bitOffset:448,bitSize:32,byteSize:4,slot:6,name:"zoom",structure:N},{...s,type:4,isRequired:!1,bitOffset:480,bitSize:32,byteSize:4,slot:7,name:"rotate",structure:N},{...s,type:2,isRequired:!1,bitOffset:512,bitSize:32,byteSize:4,slot:8,name:"antialiasing",structure:U},{...s,type:6,isRequired:!1,bitOffset:192,bitSize:64,byteSize:8,slot:9,name:"center",structure:Ve},{...s,type:6,isRequired:!1,bitOffset:256,bitSize:64,byteSize:8,slot:10,name:"centerShift",structure:Ve},{...s,type:6,isRequired:!1,bitOffset:0,bitSize:128,byteSize:16,slot:11,name:"backgroundRGBA",structure:je},{...s,type:2,isRequired:!1,bitOffset:544,bitSize:32,byteSize:4,slot:12,name:"levels",structure:U},{...s,type:2,isRequired:!1,bitOffset:576,bitSize:32,byteSize:4,slot:13,name:"levelStart",structure:U},{...s,type:1,isRequired:!1,bitOffset:712,bitSize:1,byteSize:1,slot:14,name:"transparentInside",structure:D},{...s,type:1,isRequired:!1,bitOffset:720,bitSize:1,byteSize:1,slot:15,name:"transparentOutside",structure:D},{...s,type:1,isRequired:!1,bitOffset:728,bitSize:1,byteSize:1,slot:16,name:"twist",structure:D},{...s,type:1,isRequired:!1,bitOffset:736,bitSize:1,byteSize:1,slot:17,name:"periodicityAuto",structure:D},{...s,type:4,isRequired:!1,bitOffset:608,bitSize:32,byteSize:4,slot:18,name:"rotatePolar",structure:N},{...s,type:4,isRequired:!1,bitOffset:640,bitSize:32,byteSize:4,slot:19,name:"rotateSpin",structure:N},{...s,type:1,isRequired:!1,bitOffset:744,bitSize:1,byteSize:1,slot:20,name:"hyperDroste",structure:D},{...s,type:2,isRequired:!1,bitOffset:672,bitSize:32,byteSize:4,slot:21,name:"fractalPoints",structure:U}],methods:[],template:{memory:{array:Yl}}},slot:32});Object.assign(ks,{...o,type:8,name:"@typeInfo(@typeInfo(@TypeOf(droste.createOutput)).Fn.return_type.?).ErrorUnion.error_set",length:1,byteSize:2,align:1,instance:{members:[{...s,type:6,isRequired:!1,slot:22,name:"OutOfMemory"}],methods:[],template:null},slot:87});Object.assign(Ds,{...o,type:7,name:"@typeInfo(@typeInfo(@TypeOf(droste.createOutput)).Fn.return_type.?).ErrorUnion.error_set!droste.KernelOutput(u8,droste.kernel)",length:1,byteSize:28,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitOffset:0,bitSize:192,byteSize:24,slot:0,name:"value",structure:Xe},{...s,type:3,isRequired:!1,bitOffset:192,bitSize:16,byteSize:2,name:"error",structure:ks}],methods:[],template:null},slot:39});Object.assign(Bs,{...o,type:3,name:"createOutput",length:1,byteSize:160,align:4,hasPointer:!0,instance:{members:[{...s,type:3,bitOffset:768,bitSize:32,byteSize:4,slot:0,name:"0",structure:Y},{...s,type:3,bitOffset:800,bitSize:32,byteSize:4,slot:1,name:"1",structure:Y},{...s,type:6,bitOffset:832,bitSize:192,byteSize:24,slot:2,name:"2",structure:He},{...s,type:6,bitOffset:0,bitSize:768,byteSize:96,slot:3,name:"3",structure:Ye},{...s,type:6,bitOffset:1024,bitSize:224,byteSize:28,slot:4,name:"retval",structure:Ds}],methods:[],template:null},slot:37});Object.assign(Ms,{...o,type:8,name:"@typeInfo(@typeInfo(@TypeOf(droste.createPartialOutput)).Fn.return_type.?).ErrorUnion.error_set",length:1,byteSize:2,align:1,instance:{members:[{...s,type:6,isRequired:!1,slot:22,name:"OutOfMemory"}],methods:[],template:null},slot:88});Object.assign(Ns,{...o,type:7,name:"@typeInfo(@typeInfo(@TypeOf(droste.createPartialOutput)).Fn.return_type.?).ErrorUnion.error_set!droste.KernelOutput(u8,droste.kernel)",length:1,byteSize:28,hasPointer:!0,instance:{members:[{...s,type:6,isRequired:!1,bitOffset:0,bitSize:192,byteSize:24,slot:0,name:"value",structure:Xe},{...s,type:3,isRequired:!1,bitOffset:192,bitSize:16,byteSize:2,name:"error",structure:Ms}],methods:[],template:null},slot:40});Object.assign(Ls,{...o,type:3,name:"createPartialOutput",length:1,byteSize:176,align:4,hasPointer:!0,instance:{members:[{...s,type:3,bitOffset:768,bitSize:32,byteSize:4,slot:0,name:"0",structure:Y},{...s,type:3,bitOffset:800,bitSize:32,byteSize:4,slot:1,name:"1",structure:Y},{...s,type:3,bitOffset:832,bitSize:32,byteSize:4,slot:2,name:"2",structure:Y},{...s,type:3,bitOffset:864,bitSize:32,byteSize:4,slot:3,name:"3",structure:Y},{...s,type:6,bitOffset:896,bitSize:192,byteSize:24,slot:4,name:"4",structure:He},{...s,type:6,bitOffset:0,bitSize:768,byteSize:96,slot:5,name:"5",structure:Ye},{...s,type:6,bitOffset:1088,bitSize:224,byteSize:28,slot:6,name:"retval",structure:Ns}],methods:[],template:null},slot:38});const Zl={argStruct:Bs,thunk:1,name:"createOutput"},Jl={argStruct:Ls,thunk:5,name:"createPartialOutput"};Object.assign(Fs,{...o,type:2,name:"droste",length:1,byteSize:0,align:0,instance:{members:[],methods:[],template:{memory:{array:Ws}}},static:{members:[{...s,type:7,isRequired:!1,name:"kernel",structure:$s},{...s,type:7,isRequired:!1,name:"Input",structure:He},{...s,type:7,isRequired:!1,name:"Output",structure:Xe},{...s,type:7,isRequired:!1,name:"Parameters",structure:Ye}],methods:[Zl,Jl],template:null},slot:0});const Ql=[k,rr,sr,et,ir,nr,tt,U,ae,or,ar,rt,cr,R,mr,st,ur,it,lr,nt,pr,yr,ot,fr,at,N,j,S,Ce,$e,ge,dr,ct,br,mt,hr,gr,ut,Sr,lt,wr,Vr,pt,zr,yt,D,X,Or,Ar,ft,_r,dt,ke,De,Se,Rr,bt,qr,Ur,ht,jr,gt,Be,Me,we,Pr,St,Ve,Ne,ze,Le,Oe,Fe,Ae,xr,vr,wt,Ir,Vt,Ke,Ge,_e,Er,zt,je,Tr,Ot,Cr,At,$r,_t,kr,Rt,Dr,Br,qt,Mr,Ut,Nr,Lr,jt,Fr,Pt,Kr,Gr,xt,Wr,vt,Hr,It,Xr,Yr,Et,Zr,Tt,Jr,Qr,Ct,es,$t,ts,rs,kt,ss,Dt,is,ns,Bt,os,Mt,as,Nt,cs,ms,Lt,us,Ft,ls,Kt,We,Re,ps,Gt,ys,Wt,$s,Pe,fs,ds,Y,bs,ve,Ht,He,hs,gs,Xt,Xe,Ye,ks,Ds,Bs,Ms,Ns,Ls,Fs],e1=wa(Ql),t1=Fs.constructor,r1=(async()=>{const e=new URL("droste-430f6bba.wasm",import.meta.url).href;return fetch(e)})();ga(r1,{...e1,writeBack:!0});const{createOutput:m1,createPartialOutput:s1,kernel:qs,Input:i1,Output:u1,Parameters:l1}=t1;function n1(e,t,r,i,n={},c={}){if(Array.isArray(n)){const m=n;n={};for(const[g,f]of Object.keys(qs.inputImages).entries())n[f]=m[g]}const p=new i1(void 0),y=Object.keys(qs.inputImages),l=[];let d;for(const m of y){let g=n[m];if(g||(y.length===1&&["data","width","height"].every(f=>!!n[f])?g=n:l.push(m)),p[m]=g,d){if(g.colorSpace!==d)throw new Error(`Input images must all use the same color space: ${d}`)}else d=g.colorSpace}if(l.length>0)throw new Error(`Missing input image${l.length>1?"s":""}: ${l.join(", ")}`);const u=s1(e,t,r,i,p,c),a=m=>{const g=Object.keys(m),f={};for(const b of g){const{data:{typedArray:z},width:h,height:q}=m[b];let E;if(typeof ImageData=="function"){const $=new Uint8ClampedArray(z.buffer,z.byteOffset,z.byteLength);E=new ImageData($,h,i,{colorSpace:d})}else E={data:z,width:h,height:q};if(g.length===1)return E;f[b]=E}return f};return u[Symbol.toStringTag]==="Promise"?u.then(a):a(u)}function o1(){const e={};for(let[t,r]of Object.entries(qs)){if(t==="parameters"){const i={};for(const[n,c]of Object.entries(r)){const p=i[n]={};for(let[y,l]of Object.entries(c))typeof l=="object"?"string"in l?l=l.string:l=Yi(l):typeof l=="function"&&(l=a1(l.name)),p[y]=l}r=i}else typeof r=="object"&&("string"in r?r=r.string:r=r.valueOf());e[t]=r}return e}function Yi(e){const t=[];for(let[r,i]of Object.entries(e))typeof i=="object"&&(i=Yi(i)),t[r]=i;return t}function a1(e){return{bool:"bool","@Vector(2, bool)":"bool2","@Vector(3, bool)":"bool3","@Vector(4, bool)":"bool4",i32:"int","@Vector(2, i32)":"int2","@Vector(3, i32)":"int3","@Vector(4, i32)":"int4",f32:"float","@Vector(2, f32)":"float2","@Vector(3, f32)":"float3","@Vector(4, f32)":"float4","[2]@Vector(2, f32)":"float2x2","[3]@Vector(3, f32)":"float3x3","[4]@Vector(4, f32)":"float4x4"}[e]}onmessage=e=>{const[t,r,...i]=e.data;c1(t,i).then(([n,c])=>{postMessage([t,r,n],{transfer:c})}).catch(n=>{postMessage(["error",r,n])})};async function c1(e,t){switch(e){case"getKernelInfo":return[o1(...t)];case"createPartialImageData":const i=await n1(...t),n=[];if("data"in i&&"width"in i&&"height"in i)n.push(i.data.buffer);else for(const c of Object.entries(i))n.push(i.data.buffer);return[i,n];default:throw new Error(`Unknown function: ${e}`)}}
