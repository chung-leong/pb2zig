var hn=Object.defineProperty;var yn=(t,e,n)=>e in t?hn(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n;var V=(t,e,n)=>(yn(t,typeof e!="symbol"?e+"":e,n),n);const T={Void:0,Bool:1,Int:2,Uint:3,Float:4,Object:5,Type:6,Comptime:7,Static:8,Literal:9,Null:10,Undefined:11},x={Primitive:0,Array:1,Struct:2,ExternStruct:3,PackedStruct:4,ArgStruct:5,ExternUnion:6,BareUnion:7,TaggedUnion:8,ErrorUnion:9,ErrorSet:10,Enumeration:11,Optional:12,Pointer:13,Slice:14,Vector:15,Opaque:16,Function:17};function $t(t){const{type:e,bitSize:n,byteSize:s}=t;if(e===T.Int)return`${n<=32?"":"Big"}Int${n}`;if(e===T.Uint)return`${n<=32?"":"Big"}Uint${n}`;if(e===T.Float)return`Float${n}`;if(e===T.Bool)return`Bool${s!==void 0?s*8:1}`;if(e===T.Void)return"Null"}function dn(t){const{type:e,bitSize:n}=t,s=e===T.Int;let o=s?n-1:n;if(n<=32){const i=2**o-1;return{min:s?-(2**o):0,max:i}}else{o=BigInt(o);const i=2n**o-1n;return{min:s?-(2n**o):0n,max:i}}}function ve({type:t,bitSize:e}){if(t===T.Int||t===T.Uint)return e<=32?Number:BigInt;if(t===T.Float)return Number;if(t===T.Bool)return Boolean}function Te(t){const e=ve(t);if(e)return typeof e(0)}function qt({bitOffset:t,bitSize:e,byteSize:n}){return n!==void 0||!(t&7)&&!(e&7)||e===0}function vt(t){return typeof t=="object"&&typeof t.error=="string"&&Object.keys(t).length===1}class pn extends TypeError{constructor(e){const{name:n}=e;super(`An initializer must be provided to the constructor of ${n}, even when the intended value is undefined`)}}class Ae extends TypeError{constructor(e,n,s=null){const{name:o,type:i,byteSize:r}=e,c=n.byteLength,l=r!==1?"s":"";let a;if(i===x.Slice&&!s)a=`${o} has elements that are ${r} byte${l} in length, received ${c}`;else{const u=i===x.Slice?s.length*r:r;a=`${o} has ${u} byte${l}, received ${c}`}super(a)}}class mn extends TypeError{constructor(e){const{type:n,byteSize:s,typedArray:o}=e,i=s!==1?"s":"",r=["ArrayBuffer","DataView"].map(Z);o&&r.push(Z(o.name));let c;n===x.Slice?c=`Expecting ${_t(r)} that can accommodate items ${s} byte${i} in length`:c=`Expecting ${_t(r)} that is ${s} byte${i} in length`,super(c)}}class bn extends TypeError{constructor(e,n){const{name:s}=e;let o;typeof n=="number"||typeof n=="bigint"?o=`Value given does not correspond to an item of enum ${s}: ${n}`:o=`Enum item of the type ${s} expected, received ${n}`,super(o)}}class gn extends TypeError{constructor(e,n){const{name:s}=e,o=typeof n;let i;o==="string"||o==="number"||vt(n)?(vt(n)&&(n=`{ error: ${JSON.stringify(n.error)} }`),i=`Error ${o} does not corresponds to any error in error set ${s}: ${n}`):i=`Error of the type ${s} expected, received ${n}`,super(i)}}class xe extends TypeError{constructor(e){const{name:n}=e;super(`Error given is not a part of error set ${n}`)}}class ct extends TypeError{constructor(e,n,s){const{name:o}=e,i=[];if(Array.isArray(n))for(const c of n)i.push(Z(c));else i.push(Z(n));const r=Oe(s);super(`${o} expects ${_t(i)} as argument, received ${r}`)}}class rt extends ct{constructor(e,n,s=!1){var a;const{instance:{members:[o]},type:i,typedArray:r}=e,c=[],l=Te(o);if(l){let u;switch((a=o.structure)==null?void 0:a.type){case x.Enumeration:u="enum item";break;case x.ErrorSet:u="error";break;default:u=l}c.push(`array of ${u}s`)}else c.push("array of objects");r&&c.push(r.name),i===x.Slice&&s&&c.push("length"),super(e,c.join(" or "),n)}}class Pt extends TypeError{constructor(e,n,s){const{name:o,length:i,instance:{members:[r]}}=e,{structure:{constructor:c}}=r,{length:l,constructor:a}=s,u=(n==null?void 0:n.length)??i,f=u!==1?"s":"";let p;a===c?p="only a single one":a.child===c?p=`a slice/array that has ${l}`:p=`${l} initializer${l>1?"s":""}`,super(`${o} has ${u} element${f}, received ${p}`)}}class wn extends TypeError{constructor(e,n){const{name:s}=e;super(`Missing initializers for ${s}: ${n.join(", ")}`)}}class Sn extends TypeError{constructor(e,n){const{name:s,instance:{members:o}}=e,i=o.find(c=>c.name===n);let r;i?r=`Comptime value cannot be changed: ${n}`:r=`${s} does not have a property with that name: ${n}`,super(r)}}class vn extends Error{constructor(e,n){const{name:s,instance:{members:o}}=e,i=o.length-1,r=i!==1?"s":"";super(`${s} expects ${i} argument${r}, received ${n}`)}}class Tn extends TypeError{constructor(e){super("Non-slice pointers can only be created with the help of the new operator")}}class An extends TypeError{constructor(e,n){const{name:s}=e,{constructor:{name:o}}=n;super(`Conversion of ${o} to ${s} requires an explicit cast`)}}class ae extends TypeError{constructor(e,n,s,o){const{name:i}=e;super(`${i} expects the sentinel value ${n} at ${o-1}, found at ${s}`)}}class It extends TypeError{constructor(e,n,s){const{name:o}=e;super(`${o} expects the sentinel value ${n} at ${s-1}`)}}class xn extends TypeError{constructor(e,n){super(`Unable to simultaneously align memory to ${n}-byte and ${e}-byte boundary`)}}class Dt extends TypeError{constructor(e,n){const s=Oe(n);super(`Expected ${Z(e)}, received ${s}`)}}class ue extends TypeError{constructor(){super("Null pointer")}}class En extends TypeError{constructor(e,n){const{name:s}=e;let o;if(n!=null){const i=typeof n,r=i==="object"&&n.constructor!==Object?`${n.constructor.name} object`:i;o=`${Ie(r)} ${r}`}else o=n+"";super(`${s} cannot point to ${o}`)}}class On extends TypeError{constructor(e,n){super("Pointers in fixed memory cannot point to garbage-collected object")}}class In extends TypeError{constructor(e,n){const s=$t(e);super(`${s} cannot represent the value given: ${n}`)}}class fe extends RangeError{constructor(e,n){const{name:s}=e;super(`Index exceeds the size of ${s??"array"}: ${n}`)}}class Vn extends TypeError{constructor(e){const{name:n,structure:{name:{struct:s}}}=e;super(`Unable to create ${s} as it is not situated on a byte boundary: ${n}`)}}class Mn extends TypeError{constructor(){super("Unable to modify read-only object")}}class $n extends TypeError{constructor(e){const{name:n}=e;super(`${n} cannot point to a read-only object`)}}class he extends Error{constructor(e){super(Ee(e))}}function Pn(t,e,n){const{name:s,instance:{members:o}}=t,i=`args[${e}]`,r=o.length-1,c=e!==0?"..., ":"",l=e!==r-1?", ...":"",a=c+i+l,u=Object.create(n.constructor.prototype);return u.message=`${s}(${a}): ${n.message}`,u.stack=n.stack,u}function ye(t,e,n){return n instanceof RangeError&&!(n instanceof fe)&&(n=new fe(t,e)),n}function dt(){throw new Mn}function Dn(t,e){const n=Z(t.typedArray.name),s=Z(e.constructor.name);console.warn(`Implicitly creating ${n} from ${s}`)}function Ee(t){let e=t.replace(/_/g," ");try{e=e.replace(/(\p{Uppercase}+)(\p{Lowercase}*)/gu,(n,s,o)=>{if(s.length===1)return` ${s.toLocaleLowerCase()}${o}`;if(o){const i=s.substring(0,s.length-1),r=s.charAt(s.length-1).toLocaleLowerCase();return` ${i} ${r}${o}`}else return` ${s}`}).trimStart()}catch{}return e.charAt(0).toLocaleUpperCase()+e.substring(1)}function Oe(t){const e=typeof t;let n;return e==="object"?n=t?Object.prototype.toString.call(t):"null":n=e,Z(n)}function Z(t){return`${Ie(t)} ${t}`}function Ie(t){return/^\W*[aeiou]/i.test(t)?"an":"a"}function _t(t,e="or"){const n=` ${e} `;return t.length>2?t.slice(0,-1).join(", ")+n+t[t.length-1]:t.join(n)}const b=Symbol("memory"),A=Symbol("slots"),Ht=Symbol("parent"),Xt=Symbol("name"),gt=Symbol("class"),de=Symbol("tag"),lt=Symbol("props"),jt=Symbol("getter"),Ct=Symbol("setter"),mt=Symbol("elementGetter"),bt=Symbol("elementSetter"),Wt=Symbol("addressGetter"),Ve=Symbol("addressSetter"),it=Symbol("targetGetter"),Gt=Symbol("targetSetter"),yt=Symbol("fixedLocation"),Yt=Symbol("propSetters"),z=Symbol("writeDisabler"),Me=Symbol("allKeys"),Jt=Symbol("length"),Ft=Symbol("proxy"),xt=Symbol("compat"),N=Symbol("size"),j=Symbol("align"),Kt=Symbol("array"),Tt=Symbol("pointer"),at=Symbol("constTarget"),Ut=Symbol("constProxy"),$=Symbol("copier"),pe=Symbol("resetter"),k=Symbol("normalizer"),W=Symbol("vivificator"),D=Symbol("pointerVisitor"),wt=Symbol("environment"),Vt=Symbol("attributes"),$e=Symbol("more");function Q(t){return function(){const e=this[b];this[b]=null,this[A]&&(this[A]={}),t.releaseFixedView(e)}}function me(t,e,n){if(t+e<=8){const s=2**e-1;if(n)return function(o,i,r){const l=i.getUint8(r)>>t&s;o.setUint8(0,l)};{const o=255^s<<t;return function(i,r,c){const l=r.getUint8(0),u=i.getUint8(c)&o|(l&s)<<t;i.setUint8(c,u)}}}else{const s=8-t,o=2**s-1;if(n){const r=2**(e%8)-1;return function(c,l,a){let u=a,f=0,p=l.getUint8(u++),h,d=p>>t&o,y=s,m=e;do m>y&&(p=l.getUint8(u++),d=d|p<<y),h=m>=8?d&255:d&r,c.setUint8(f++,h),d>>=8,m-=8;while(m>0)}}else{const r=2**((e-s)%8)-1,c=255^o<<t,l=255^r;return function(a,u,f){let p=0,h=f,d=a.getUint8(h),y,m,g=d&c,w=t,O=e+w;do O>w&&(y=u.getUint8(p++),g=g|y<<w,w+=8),O>=8?m=g&255:(d=a.getUint8(h),m=d&l|g&r),a.setUint8(h++,m),g>>=8,w-=8,O-=8;while(O>0)}}}}function B(t,e=!1){const n=Pe(t,e);return function(s){_.call(this),_.call(s);const o=s[b],i=this[b];n(i,o)}}function Pe(t,e=!1){if(!e){const n=jn[t];if(n)return n}return t&7?t&3?t&1?Cn:Fn:zn:Nn}const jn={1:kn,2:Bn,4:Ln,8:Un,16:Rn,32:_n};function Cn(t,e){for(let n=0,s=t.byteLength;n<s;n++)t.setInt8(n,e.getInt8(n))}function Fn(t,e){for(let n=0,s=t.byteLength;n<s;n+=2)t.setInt16(n,e.getInt16(n,!0),!0)}function zn(t,e){for(let n=0,s=t.byteLength;n<s;n+=4)t.setInt32(n,e.getInt32(n,!0),!0)}function Nn(t,e){for(let n=0,s=t.byteLength;n<s;n+=8)t.setInt32(n,e.getInt32(n,!0),!0),t.setInt32(n+4,e.getInt32(n+4,!0),!0)}function kn(t,e){t.setInt8(0,e.getInt8(0))}function Bn(t,e){t.setInt16(0,e.getInt16(0,!0),!0)}function Ln(t,e){t.setInt32(0,e.getInt32(0,!0),!0)}function Un(t,e){t.setInt32(0,e.getInt32(0,!0),!0),t.setInt32(4,e.getInt32(4,!0),!0)}function Rn(t,e){t.setInt32(0,e.getInt32(0,!0),!0),t.setInt32(4,e.getInt32(4,!0),!0),t.setInt32(8,e.getInt32(8,!0),!0),t.setInt32(12,e.getInt32(12,!0),!0)}function _n(t,e){t.setInt32(0,e.getInt32(0,!0),!0),t.setInt32(4,e.getInt32(4,!0),!0),t.setInt32(8,e.getInt32(8,!0),!0),t.setInt32(12,e.getInt32(12,!0),!0),t.setInt32(16,e.getInt32(16,!0),!0),t.setInt32(20,e.getInt32(20,!0),!0),t.setInt32(24,e.getInt32(24,!0),!0),t.setInt32(28,e.getInt32(28,!0),!0)}function Wn(t,e){const n=Gn(e);return function(){_.call(this);const s=this[b];n(s,t,e)}}function Gn(t){const e=Jn[t];return e||(t&7?t&3?t&1?qn:Hn:Xn:Yn)}const Jn={1:Kn,2:Zn,4:Qn,8:ts,16:es,32:ns};function qn(t,e,n){for(let s=e,o=e+n;s<o;s++)t.setInt8(s,0)}function Hn(t,e,n){for(let s=e,o=e+n;s<o;s+=2)t.setInt16(s,0,!0)}function Xn(t,e,n){for(let s=e,o=e+n;s<o;s+=4)t.setInt32(s,0,!0)}function Yn(t,e,n){for(let s=e,o=e+n;s<o;s+=8)t.setInt32(s,0,!0),t.setInt32(s+4,0,!0)}function Kn(t,e){t.setInt8(e,0)}function Zn(t,e){t.setInt16(e,0,!0)}function Qn(t,e){t.setInt32(e,0,!0)}function ts(t,e){t.setInt32(e+0,0,!0),t.setInt32(e+4,0,!0)}function es(t,e){t.setInt32(e+0,0,!0),t.setInt32(e+4,0,!0),t.setInt32(e+8,0,!0),t.setInt32(e+12,0,!0)}function ns(t,e){t.setInt32(e+0,0,!0),t.setInt32(e+4,0,!0),t.setInt32(e+8,0,!0),t.setInt32(e+12,0,!0),t.setInt32(e+16,0,!0),t.setInt32(e+20,0,!0),t.setInt32(e+24,0,!0),t.setInt32(e+28,0,!0)}function _(){const t=this[b],e=t[b];if(!e||t.buffer.byteLength!==0)return!1;const{memory:n,address:s,len:o}=e,i=new DataView(n.buffer,s,o);return i[b]=e,this[b]=i,!0}function ss(t,e){return ze(t,e,()=>{if(qt(e)){const{byteSize:n}=e,s=$t({type:T.Int,bitSize:n*8});if(t==="get"){const o=DataView.prototype[`get${s}`];return function(i,r){return!!o.call(this,i,r)}}else{const o=DataView.prototype[`set${s}`],i=n>4?1n:1,r=n>4?0n:0;return function(c,l,a){o.call(this,c,l?i:r,a)}}}else return je(t,e)})}function At(t,e){return ze(t,e,n=>DataView.prototype[n]?DataView.prototype[n]:je(t,e))}const De={};function So(){De[T.Uint]=os}function je(t,e){const n=De[e.type];return n(t,e)}function os(t,e){return qt(e)?us(t,e):fs(t,e)}function zt(t,e,n){const{type:s,byteSize:o,typedArray:i}=t;let r;const c=e==null?void 0:e[Symbol.toStringTag];if(c==="DataView")r=e;else if(c==="ArrayBuffer"||c==="SharedArrayBuffer")r=n.obtainView(e,0,e.byteLength);else if(i&&c===i.name||c==="Uint8ClampedArray"&&i===Uint8Array)r=n.obtainView(e.buffer,e.byteOffset,e.byteLength);else if(c==="Uint8Array"&&typeof Buffer=="function"&&e instanceof Buffer)r=n.obtainView(e.buffer,e.byteOffset,e.byteLength);else{const l=e==null?void 0:e[b];if(l){const{constructor:a,instance:{members:[u]}}=t;if(e instanceof a)return l;if(s===x.Array||s===x.Slice||s===x.Vector){const{byteSize:f,structure:{constructor:p}}=u,h=Fe(e,p);if(h!==void 0){if(s===x.Slice||h*f===o)return l;throw new Pt(t,null,e)}}}}return r&&o!==void 0&&Ce(r,t),r}function is(t){if((t==null?void 0:t[Symbol.toStringTag])!=="DataView")throw new Dt("a DataView",t);return t}function Ce(t,e){const{byteSize:n,type:s}=e;if(s===x.Slice?t.byteLength%n!==0:t.byteLength!==n)throw new Ae(e,t)}function Et(t,e,n,s,o){const{byteSize:i,type:r,sentinel:c}=e,l=r===x.Slice;if(this[b]){const a=l?i*this.length:i;if(t.byteLength!==a)throw new Ae(e,t,this);const u={[b]:t};c==null||c.validateData(u,this.length),this[$](u)}else{const{shapeDefiner:a}=o;Ce(t,e);const u=t.byteLength/i,f={[b]:t};c==null||c.validateData(f,u),s&&(n=!0),a.call(this,n?null:t,u,s),n&&this[$](f)}}function Fe(t,e){const{constructor:n}=t;if(n===e)return 1;if(n.child===e)return t.length}function rs(t,e,n){const s=zt(t,e,n);if(!s)throw console.log(e),new mn(t);return s}function ut(t){const{type:e,byteSize:n}=t;if(e===T.Int)switch(n){case 1:return Int8Array;case 2:return Int16Array;case 4:return Int32Array;case 8:return BigInt64Array}else if(e===T.Uint)switch(n){case 1:return Uint8Array;case 2:return Uint16Array;case 4:return Uint32Array;case 8:return BigUint64Array}else if(e===T.Float)switch(n){case 4:return Float32Array;case 8:return Float64Array}else if(e===T.Object)return t.structure.typedArray;return null}function cs(t,e){const n=t==null?void 0:t[Symbol.toStringTag];return!!e&&n===e.name}function ls(t,e){const n=e[xt];if(n){const s=t==null?void 0:t[Symbol.toStringTag];if(n.includes(s))return!0}return!!(e.child&&Fe(t,e.child)!==void 0)}function Nt(t){const{typedArray:e}=t,n=[];return e&&(n.push(e.name),n.push("DataView"),(e===Uint8Array||e===Int8Array)&&(n.push("ArrayBuffer"),n.push("SharedArrayBuffer"),e===Uint8Array&&n.push("Uint8ClampedArray"))),n}function as(t){const e=DataView.prototype.getBigUint64,n=DataView.prototype.setBigUint64,s=Math.ceil(t/64);return{get:function(o,i){let r=0n;if(i)for(let c=0,l=o+(s-1)*8;c<s;c++,l-=8){const a=e.call(this,l,i);r=r<<64n|a}else for(let c=0,l=o;c<s;c++,l+=8){const a=e.call(this,l,i);r=r<<64n|a}return r},set:function(o,i,r){let c=i;const l=0xFFFFFFFFFFFFFFFFn;if(r)for(let a=0,u=o;a<s;a++,u+=8){const f=c&l;n.call(this,u,f,r),c>>=64n}else{c<<=BigInt(s*64-t);for(let a=0,u=o+(s-1)*8;a<s;a++,u-=8){const f=c&l;n.call(this,u,f,r),c>>=64n}}return c}}}function us(t,e){const{bitSize:n,byteSize:s}=e;if(n<64){const o=$t({...e,bitSize:s*8}),i=DataView.prototype[`get${o}`],r=DataView.prototype[`set${o}`],c=n<=32?2**n-1:2n**BigInt(n)-1n;return t==="get"?function(l,a){return i.call(this,l,a)&c}:function(l,a,u){const f=a&c;r.call(this,l,f,u)}}else{const{get:o,set:i}=as(n),r=2n**BigInt(n)-1n;return t==="get"?function(c,l){return o.call(this,c,l)&r}:function(c,l,a){const u=l&r;i.call(this,c,u,a)}}}function fs(t,e){const{bitSize:n,bitOffset:s}=e,o=s&7;if(o+n<=8){const i=DataView.prototype.setUint8,r=DataView.prototype.getUint8,c=2**n-1;if(t==="get")return function(l){return r.call(this,l)>>>o&c};{const l=255^c<<o;return function(a,u){const p=r.call(this,a)&l|(u&c)<<o;i.call(this,a,p)}}}return hs(t,e)}function hs(t,e){const{bitSize:n,bitOffset:s}=e,o=s&7,i=[1,2,4,8].find(c=>c*8>=n)??Math.ceil(n/64)*64,r=new DataView(new ArrayBuffer(i));if(t==="get"){const c=At("get",{...e,byteSize:i}),l=me(o,n,!0);return function(a,u){return l(r,this,a),c.call(r,0,u)}}else{const c=At("set",{...e,byteSize:i}),l=me(o,n,!1);return function(a,u,f){c.call(r,0,u,f),l(this,r,a)}}}const be={};function ze(t,e,n){const{type:s,bitOffset:o,bitSize:i,structure:r}=e,c=o&7,l=$t(e),a=qt(e)?"":`Bit${c}`,u=s===T.Int||s===T.Uint;let f=`${t}${l}${a}`,p=!1,h=f;if(u&&i===64){const y=r==null?void 0:r.name;(y==="usize"||y==="isize")&&(f+="Size",p=!0)}let d=be[f];if(!d){if(u&&t==="set"){const y=ve(e),m=n(h);d=function(g,w,O){m.call(this,g,y(w),O)}}else if(p&&t==="get"){const y=n(h),m=BigInt(Number.MIN_SAFE_INTEGER),g=BigInt(Number.MAX_SAFE_INTEGER);d=function(w,O){const P=y.call(this,w,O);return m<=P&&P<=g?Number(P):P}}else d=n(f);d&&d.name!==f&&Object.defineProperty(d,"name",{value:f,configurable:!0,writable:!1}),be[f]=d}return d}function ys({type:t}){switch(t){case T.Type:case T.Comptime:case T.Literal:return!0;default:return!1}}const tt={};function vo(){tt[T.Bool]=bs}function To(){tt[T.Int]=gs}function ds(){tt[T.Uint]=ws}function Ao(){tt[T.Float]=Ss}function xo(){tt[T.Object]=xs}function Eo(){tt[T.Type]=Os}function Oo(){tt[T.Comptime]=Is}const Zt={};function ps(){Zt[x.Enumeration]=vs}function ms(){Zt[x.ErrorSet]=Ts}function C(t,e){const n=tt[t.type];return n(t,e)}function Ne(t,e){const{structure:n}=e,s=Zt[n==null?void 0:n.type];return s?s(t,n):t}function bs(t,e){return kt(t,e,ss)}function gs(t,e){const n=ke(e,At),s=kt(t,e,n);return Ne(s,t)}function ws(t,e){const n=ke(e,At),s=kt(t,e,n);return Ne(s,t)}function ke(t,e){return function(n,s){const{runtimeSafety:o=!0}=t,i=e(n,s);if(o&&n==="set"){const{min:r,max:c}=dn(s);return function(l,a,u){if(a<r||a>c)throw new In(s,a);i.call(this,l,a,u)}}return i}}function Ss(t,e){return kt(t,e,At)}function vs(t,e){const n=function(s){const{constructor:o}=e,i=o(s);if(!i)throw new bn(e,s);return i};return{get:t.get.length===0?function(o){const i=t.get.call(this);return o==="number"?i:n(i)}:function(o){const i=t.get.call(this,o);return n(i)},set:t.set.length===1?function(o,i){i!=="number"&&(o=n(o)[Symbol.toPrimitive]()),t.set.call(this,o)}:function(o,i){const r=n(i);t.set.call(this,o,r[Symbol.toPrimitive]())}}}function Ts(t,e){const n=function(s){const{constructor:o}=e,i=o(s);if(!i)throw s instanceof Error?new xe(e):new gn(e,s);return i};return{get:t.get.length===0?function(o){const i=t.get.call(this);return o==="number"?i:n(i)}:function(o){const i=t.get.call(this,o);return n(i)},set:t.set.length===1?function(o,i){if(i!=="number"){const r=n(o);o=Number(r)}t.set.call(this,o)}:function(o,i){const r=n(i);i=Number(r),t.set.call(this,o,i)}}}function Qt(t){switch(t.type){case x.Primitive:case x.ErrorUnion:case x.Optional:case x.Enumeration:case x.ErrorSet:return!0;default:return!1}}function Be(t){return(this[A][t]??this[W](t))[jt]()}function Le(t){return this[A][t]??this[W](t)}function As(t,e){(this[A][t]??this[W](t))[Ct](e)}function te(t,{get:e,set:n}){return t!==void 0?{get:function(){return e.call(this,t)},set:n?function(s){return n.call(this,t,s)}:void 0}:{get:e,set:n}}function xs(t,e){const{structure:n,slot:s}=t;return te(s,{get:Qt(n)?Be:Le,set:As})}function Es(t){const e=this[A][t];return e==null?void 0:e.constructor}function Os(t,e){const{slot:n}=t;return te(n,{get:Es})}function Is(t,e){const{slot:n,structure:s}=t;return te(n,{get:Qt(s)?Be:Le})}function kt(t,e,n){const{littleEndian:s=!0}=e,{bitOffset:o,byteSize:i}=t,r=n("get",t),c=n("set",t);if(o!==void 0){const l=o>>3;return{get:function(){try{return r.call(this[b],l,s)}catch(u){if(u instanceof TypeError&&_.call(this))return r.call(this[b],l,s);throw u}},set:function(u){try{return c.call(this[b],l,u,s)}catch(f){if(f instanceof TypeError&&_.call(this))return c.call(this[b],l,u,s);throw f}}}}else return{get:function(a){try{return r.call(this[b],a*i,s)}catch(u){if(u instanceof TypeError&&_.call(this))return r.call(this[b],a*i,s);throw ye(t,a,u)}},set:function(a,u){try{return c.call(this[b],a*i,u,s)}catch(f){if(f instanceof TypeError&&_.call(this))return c.call(this[b],a*i,u,s);throw ye(t,a,f)}}}}function F(t,e){for(const[n,s]of Object.entries(e))if(s){const{set:o,get:i,value:r,enumerable:c,configurable:l=!0,writable:a=!0}=s;Object.defineProperty(t,n,i?{get:i,set:o,configurable:l,enumerable:c}:{value:r,configurable:l,enumerable:c,writable:a})}for(const n of Object.getOwnPropertySymbols(e)){const s=e[n];s&&Object.defineProperty(t,n,s)}}function H(t,e,n){const s={};for(const[r,c]of Object.entries(e))c!=null&&c.set&&r!=="$"&&(s[r]=c.set);const{get:o,set:i}=e.$;return F(t.prototype,{[Me]:{value:Object.keys(s)},[Ct]:{value:i},[jt]:{value:o},[Yt]:{value:s},[at]:{value:null},...e}),F(t,n),t}function ft(){const t=Object.getOwnPropertyDescriptors(this.constructor.prototype);for(const[e,n]of Object.entries(t))n.set&&(n.set=dt,Object.defineProperty(this,e,n));Object.defineProperty(this,Ct,{value:dt}),Object.defineProperty(this,at,{value:this})}function X(t,e,n){const{byteSize:s,align:o,instance:{members:i,template:r},hasPointer:c}=t,{modifier:l,initializer:a,finalizer:u,alternateCaster:f,shapeDefiner:p}=e,h=Vs(i);let d;if(r!=null&&r[A]){const g=i.filter(w=>ys(w));g.length>0&&(d=g.map(w=>w.slot))}const y=new Ms,m=function(g,w={}){const{fixed:O=!1}=w,P=this instanceof m;let M,v;if(P){if(arguments.length===0)throw new pn(t);M=this,h&&(M[A]={}),p?(a.call(M,g,O),v=M[b]):M[b]=v=n.allocateMemory(s,o,O)}else{if(f&&(M=f.call(this,g,w),M!==!1)||(v=rs(t,g,n),M=y.find(v)))return M;M=Object.create(m.prototype),p?Et.call(M,v,t,!1,!1,{shapeDefiner:p}):M[b]=v,h&&(M[A]={})}if(d)for(const E of d)M[A][E]=r[A][E];return l&&l.call(M),P&&(p||a.call(M,g)),u&&(M=u.call(M)),y.save(v,M)};return m}function Ot({source:t}){const e=t[A][0];e&&this[Gt](e)}function et(t){const{instance:{template:e}}=t;return function(n,s){var f;const o=Object.keys(n),i=this[Yt],r=this[Me];for(const p of o)if(!(p in i))throw new Sn(t,p);let c=0,l=0,a=0,u=0;for(const p of r){const h=i[p];h.special?p in n&&u++:(c++,p in n?l++:h.required&&a++)}if(a!==0&&u===0){const p=r.filter(h=>i[h].required&&!(h in n));throw new wn(t,p)}if(u+l>o.length)for(const p of r)p in n&&(o.includes(p)||o.push(p));l<c&&u===0&&e&&(e[b]&&this[$](e),(f=this[D])==null||f.call(this,Ot,{vivificate:!0,source:e}));for(const p of o)i[p].call(this,n[p],s);return o.length}}function Vs(t){for(const{type:e}of t)switch(e){case T.Object:case T.Comptime:case T.Type:case T.Literal:return!0}return!1}function Ue(){return this}class Ms{constructor(){V(this,"map",new WeakMap)}find(e){return this.map.get(e)}save(e,n){return this.map.set(e,n),n}}const ge={},we={};function St(t,e="utf-8"){let n=ge[e];n||(n=ge[e]=new TextDecoder(e));let s;if(Array.isArray(t))if(t.length===1)s=t[0];else{let o=0;for(const c of t)o+=c.length;const{constructor:i}=t[0];s=new i(o);let r=0;for(const c of t)s.set(c,r),r+=c.length}else s=t;return n.decode(s)}function $s(t,e="utf-8"){switch(e){case"utf-16":{const{length:n}=t,s=new Uint16Array(n);for(let o=0;o<n;o++)s[o]=t.charCodeAt(o);return s}default:{let n=we[e];return n||(n=we[e]=new TextEncoder),n.encode(t)}}}function Ps(t){const e=new Uint8Array(t.buffer,t.byteOffset,t.byteLength),n=String.fromCharCode.apply(null,e);return btoa(n)}function Ds(t){const e=atob(t),n=new Uint8Array(e.length);for(let s=0;s<n.byteLength;s++)n[s]=e.charCodeAt(s);return new DataView(n.buffer)}function L(){const t=new Map,e={error:"throw"},n=function(s){const o=s==null?void 0:s[k];if(o){let i=t.get(s);return i===void 0&&(i=o.call(s,n,e),t.set(s,i)),i}else return s};return n(this)}const js=BigInt(Number.MAX_SAFE_INTEGER),Cs=BigInt(Number.MIN_SAFE_INTEGER);function G(){const t=new Map,e={error:"return"},n=function(s){const o=s==null?void 0:s[k];if(o){let i=t.get(s);return i===void 0&&(i=o.call(s,n,e),typeof(i==null?void 0:i.toJSON)=="function"&&(i=i.toJSON()),t.set(s,i)),i}else return typeof s=="bigint"&&Cs<=s&&s<=js?Number(s):s};return n(this)}function Re(t,e){const n=ee(()=>this.$,e);return t(n)}function ee(t,e={}){const{error:n="throw"}=e;try{return t()}catch(s){if(n==="return")return s;throw s}}function nt(t,e={}){return Bt({get(){return _.call(this),this[b]},set(n,s){is(n),Et.call(this,n,t,!0,s,e)}})}function st(t,e={}){return Bt({get(){return Ps(this.dataView)},set(n,s){if(typeof n!="string")throw new Dt("string",n);const o=Ds(n);Et.call(this,o,t,!1,s,e)}})}function _e(t,e={}){const{sentinel:n,instance:{members:s}}=t,{byteSize:o}=s[0];return Bt({get(){const i=this.dataView,r=o===1?Int8Array:Int16Array,c=new r(i.buffer,i.byteOffset,this.length),l=St(c,`utf-${o*8}`);return(n==null?void 0:n.value)===void 0?l:l.slice(0,-1)},set(i,r){if(typeof i!="string")throw new Dt("a string",i);(n==null?void 0:n.value)!==void 0&&i.charCodeAt(i.length-1)!==n.value&&(i=i+String.fromCharCode(n.value));const c=$s(i,`utf-${o*8}`),l=new DataView(c.buffer);Et.call(this,l,t,!1,r,e)}})}function pt(t,e={}){const{typedArray:n}=t;return Bt({get(){const s=this.dataView,o=s.byteLength/n.BYTES_PER_ELEMENT;return new n(s.buffer,s.byteOffset,o)},set(s,o){if(!cs(s,n))throw new Dt(n.name,s);const i=new DataView(s.buffer,s.byteOffset,s.byteLength);Et.call(this,i,t,!0,o,e)}})}function Bt({get:t,set:e}){return t.special=e.special=!0,{get:t,set:e}}let K,Mt;function We(t,e){const{name:n,byteSize:s,align:o,instance:{members:[i]}}=t;if(Mt||(Mt=class extends Ns{},K=We({...t,name:"anyerror"},e)),K&&n==="anyerror")return t.constructor=K,t.typedArray=ut(i),K;const r=Mt,{get:c,set:l}=C(i,e),a=["string","number"],u=et(t),f=function(g){if(g instanceof h[gt])l.call(this,g);else if(g&&typeof g=="object"&&!vt(g)){if(u.call(this,g)===0)throw new ct(t,a,g)}else g!==void 0&&l.call(this,g)},p=function(g){if(typeof g=="number"||typeof g=="string")return h[g];if(g instanceof h[gt])return h[Number(g)];if(vt(g))return h[`Error: ${g.error}`];if(zt(t,g,e))return!1;throw new ct(t,a,g)},h=t.constructor=X(t,{initializer:f,alternateCaster:p},e),d=t.typedArray=ut(i),y={$:{get:c,set:l},dataView:nt(t),base64:st(t),typedArray:d&&pt(t),valueOf:{value:L},toJSON:{value:G},delete:{value:Q(e)},[$]:{value:B(s)},[k]:{value:c},[z]:{value:ft}},m={[j]:{value:o},[N]:{value:s},[gt]:{value:r},[lt]:n==="anyerror"?{value:[]}:void 0};return H(h,y,m)}function Fs(t,e,n){const s=n[jt]("number");let o=K[s];if(!o){const c=t[gt];o=new c(e,s)}const i=String(o),r={[s]:{value:o},[i]:{value:o},[e]:{value:o}};F(t,r),F(K,r),K[lt].push(e)}function zs(){Mt=K=void 0}class Ns extends Error{constructor(e,n){super(Ee(e)),this.number=n}[Symbol.toPrimitive](e){switch(e){case"string":case"default":return Error.prototype.toString.call(this,e);default:return this.number}}toJSON(){return{error:this.message}}}function ks(t,e){const n=(s,{methods:o},i)=>{const r={},c=/^(get|set)\s+([\s\S]+)/;for(const l of o){const a=e.createCaller(l,i),u=c.exec(a.name);if(u){const f=u[1],p=u[2],h=f==="get"?0:1;if(Bs(l,i)===h){let y=r[p];y||(y=r[p]={configurable:!0,enumerable:!0}),y[f]=a}}else r[a.name]={value:a,configurable:!0,writable:!0}}F(s,r)};n(t.constructor,t.static,!1),n(t.constructor.prototype,t.instance,!0)}function Bs(t,e){const{argStruct:{instance:{members:n}}}=t;return n.length-(e?2:1)}function Ls(t,e){const{byteSize:n,align:s,instance:{members:[o]}}=t,{get:i,set:r}=C(o,e),c=["string","number","tagged union"],l=et(t),a=function(m){if(m&&typeof m=="object"){if(l.call(this,m)===0)throw new ct(t,c,m)}else m!==void 0&&r.call(this,m)},u=function(m){if(typeof m=="string"||typeof m=="number"||typeof m=="bigint"){let g=f[m];if(!g&&f[$e]&&typeof m!="string"){g=new f(void 0);debugger;r.call(g,m,"number"),Ge(f,`${m}`,g)}return g}else{if(m instanceof f)return m;if((m==null?void 0:m[de])instanceof f)return m[de];if(zt(t,m,e))return!1;throw new ct(t,c,m)}},f=t.constructor=X(t,{initializer:a,alternateCaster:u},e),p=t.typedArray=ut(o),h=function(m){switch(m){case"string":case"default":return this.$[Xt];default:return i.call(this,"number")}},d={$:{get:i,set:r},dataView:nt(t),base64:st(t),typedArray:p&&pt(t),valueOf:{value:L},toString:{value:L},toJSON:{value:G},delete:{value:Q(e)},[Symbol.toPrimitive]:{value:h},[$]:{value:B(n)},[k]:{value:Us},[z]:{value:ft}},y={[j]:{value:s},[N]:{value:n}};return H(f,d,y)}function Us(t){return t(this.$[Xt])}function Ge(t,e,n){if(e!==void 0){if(n instanceof t){F(n,{[Xt]:{value:e}});const s=n[Symbol.toPrimitive]();F(t,{[s]:{value:n},[e]:{value:n}})}}else F(t,{[$e]:{value:!0}})}function Rs(t,e){const{byteSize:n,align:s,instance:{members:[o]},isConst:i}=t,{runtimeSafety:r=!0}=e,{structure:c}=o,{type:l,sentinel:a,length:u}=c,f=l===x.Slice&&c.length===void 0&&!a,p=f?n/2:n,{get:h,set:d}=C({type:T.Uint,bitOffset:0,bitSize:p*8,byteSize:p,structure:{byteSize:p}},e),{get:y,set:m}=f?C({type:T.Uint,bitOffset:p*8,bitSize:p*8,byteSize:p,structure:{name:"usize",byteSize:p}},e):{},g=function(){const S=this[yt];if(S){const I=this[Wt]();if(I.address!==S.address||I.length!==S.length){const{constructor:J}=c,Y=e.findMemory(I.address,I.length,J[N]),Lt=J.call(wt,Y);this[A][0]=Lt,this[yt]=I}}},w=function(){g.call(this);const S=this[A][0];if(!S)throw new ue;return i?Je(S):S},O=function(S){if(e.inFixedMemory(this))if(e.inFixedMemory(S)){const I={address:e.getViewAddress(S[b]),length:f?S.length:ce};re.call(this,I),this[yt]=I}else throw new On(t,S);this[A][0]=S},P=Qt(c)?function(){return w.call(this)[jt]()}:w,M=i?dt:function(S){g.call(this);const I=this[A][0];if(!I)throw new ue;return I[Ct](S)},v=function(S,I){const J=c.constructor;if(this===wt||this===Ht||S instanceof ot)return!1;if(Se(S,J))return new ot(J(S["*"]),I);if(l===x.Slice)return new ot(J(S),I);throw new Tn(t)},E=function(){const S=l===x.Pointer?{}:Xs,I=new Proxy(this,S);return Object.defineProperty(this,Ft,{value:I}),I},R=function(S){var J;const I=c.constructor;if(Se(S,I)){if(!i&&S.constructor.const)throw new An(t,S);S=S[A][0]}if(S instanceof I){_.call(S);const Y=S[at];if(Y)if(i)S=Y;else throw new $n(t)}else if(ls(S,I)){const Y=zt(c,S,e);S=I(Y)}else if(S!==void 0&&!S[b]){const Y=e.inFixedMemory(this),Lt=new I(S,{fixed:Y});if(r&&c.typedArray){const le=(J=S==null?void 0:S.buffer)==null?void 0:J[Symbol.toStringTag];(le==="ArrayBuffer"||le==="SharedArrayBuffer")&&Dn(c,S)}S=Lt}else if(S!==void 0)throw new En(t,S);this[Gt](S)},ot=t.constructor=X(t,{initializer:R,alternateCaster:v,finalizer:E},e),re=function({address:S,length:I}){d.call(this,S),m==null||m.call(this,I)},ce=l!=x.Slice?1:u,an=function(){const S=h.call(this),I=y?y.call(this):a?S?e.findSentinel(S,a.bytes)+1:0:ce;return{address:S,length:I}},un={"*":{get:P,set:M},$:{get:ne,set:R},valueOf:{value:L},toJSON:{value:G},delete:{value:Gs},[Symbol.toPrimitive]:l===x.Primitive&&{value:Js},[it]:{value:w},[Gt]:{value:O},[Wt]:{value:an},[Ve]:{value:re},[D]:{value:Hs},[$]:{value:B(n)},[k]:{value:Ws},[yt]:{value:void 0,writable:!0},[z]:{value:_s}},fn={child:{get:()=>c.constructor},const:{value:i},[j]:{value:s},[N]:{value:n}};return H(ot,un,fn)}function _s(){const t=this[Tt],e=Object.getOwnPropertyDescriptor(t.constructor.prototype,"$");e.set=dt,Object.defineProperty(t,"$",e),Object.defineProperty(t,at,{value:t})}function Ws(t){let e;try{e=this["*"]}catch{e=Symbol.for("inaccessible")}return t(e)}function Gs(){const t=this[A][0];t==null||t.delete()}function Js(t){return this[A][0][Symbol.toPrimitive](t)}function ne(){return this[Ft]}function qs({isActive:t}){this[A][0]&&!t(this)&&(this[A][0]=void 0)}function Hs(t,e={}){const{source:n,isActive:s=q,isMutable:o=q}=e;t.call(this,{source:n,isActive:s,isMutable:o})}function Se(t,e){var n;return((n=t==null?void 0:t.constructor)==null?void 0:n.child)===e&&t["*"]}function Je(t){let e=t[Ut];return e||(Object.defineProperty(t,Ut,{value:void 0,configurable:!0}),e=new Proxy(t,Ys),Object.defineProperty(t,Ut,{value:e})),e}const Xs={get(t,e){return e===Tt?t:e in t?t[e]:t[it]()[e]},set(t,e,n){if(e in t)t[e]=n;else{const s=t[it]();s[e]=n}return!0},deleteProperty(t,e){if(e in t)delete t[e];else{const n=t[it]();delete n[e]}return!0},has(t,e){if(e in t)return!0;{const n=t[it]();return e in n}}},Ys={get(t,e){if(e===at)return t;{const n=t[e];return(n==null?void 0:n[at])===null?Je(n):n}},set(t,e,n){const s=t[Tt];if(s&&!(e in s))return t[e]=n,!0;dt()}};function q(){return!0}function Ks(t,e){const{length:n,byteSize:s,align:o,instance:{members:[i]}}=t,{bitSize:r,structure:c}=i,l={};for(let y=0,m=0;y<n;y++,m+=r){const{get:g,set:w}=C({...i,bitOffset:m},e);l[y]={get:g,set:w,configurable:!0}}const a=et(t),u=function(y){if(y instanceof f)this[$](y);else if(y!=null&&y[Symbol.iterator]){let m=y.length;if(typeof m!="number"&&(y=[...y],m=y.length),m!==n)throw new Pt(t,this,y);let g=0;for(const w of y)this[Yt][g++].call(this,w)}else if(y&&typeof y=="object"){if(a.call(this,y)===0)throw new rt(t,y)}else if(y!==void 0)throw new rt(t,y)},f=t.constructor=X(t,{initializer:u},e),p=t.typedArray=ut(i),h={...l,$:{get:Ue,set:u},length:{value:n},dataView:nt(t),base64:st(t),typedArray:p&&pt(t),valueOf:{value:L},toJSON:{value:G},entries:{value:Zs},delete:{value:Q(t)},[Symbol.iterator]:{value:He},[$]:{value:B(s)},[k]:{value:qe},[z]:{value:ft}},d={child:{get:()=>c.constructor},[xt]:{value:Nt(t)},[j]:{value:o},[N]:{value:s}};return H(f,h,d)}function qe(t){const e=[];for(const n of this)e.push(t(n));return e}function He(){const t=this,e=this.length;let n=0;return{next(){let s,o;if(n<e){const i=n++;s=t[i],o=!1}else o=!0;return{value:s,done:o}}}}function Xe(){const t=this,e=this.length;let n=0;return{next(){let s,o;if(n<e){const i=n++;s=[i,t[i]],o=!1}else o=!0;return{value:s,done:o}}}}function Zs(){return{[Symbol.iterator]:Xe.bind(this),length:this.length}}function Qs(t,e){const{byteSize:n,align:s,instance:{members:o},isTuple:i,hasPointer:r}=t,c={};for(const d of o){const{get:y,set:m}=C(d,e);c[d.name]={get:y,set:m,configurable:!0,enumerable:!0},d.isRequired&&m&&(m.required=!0)}const l=!!o.find(d=>d.type===T.Object),a=et(t),u=function(d){if(d instanceof f)this[$](d),r&&this[D](Ot,{vivificate:!0,source:d});else if(d&&typeof d=="object")a.call(this,d);else if(d!==void 0)throw new ct(t,"object",d)},f=t.constructor=X(t,{initializer:u},e),p={$:{get:Ue,set:u},dataView:nt(t),base64:st(t),length:i&&{value:o.length>0?parseInt(o[o.length-1].name)+1:0},valueOf:{value:L},toJSON:{value:G},delete:{value:Q(e)},entries:i&&{value:Xe},...c,[Symbol.iterator]:{value:i?He:Ze},[$]:{value:B(n)},[W]:l&&{value:se(t)},[D]:r&&{value:oe(t,q)},[k]:{value:i?qe:Ye},[z]:{value:ft},[lt]:{value:o.map(d=>d.name)}},h={[j]:{value:s},[N]:{value:n}};return H(f,p,h)}function Ye(t,e){const n={};for(const[s,o]of Ke.call(this,e))n[s]=t(o);return n}function Ke(t){return{[Symbol.iterator]:to.bind(this,t),length:this[lt].length}}function Ze(t){return Ke.call(this,t)[Symbol.iterator]()}function to(t){const e=this,n=this[lt];let s=0;return{next(){let o,i;if(s<n.length){const r=n[s++];o=[r,ee(()=>e[r],t)],i=!1}else i=!0;return{value:o,done:i}}}}function se(t){const{instance:{members:e}}=t,n={};for(const s of e.filter(o=>o.type===T.Object))n[s.slot]=s;return function(o){const i=n[o],{bitOffset:r,byteSize:c,structure:{constructor:l}}=i,a=this[b],f=a.byteOffset+(r>>3);let p=c;if(p===void 0){if(r&7)throw new Vn(i);p=i.bitSize>>3}const h=new DataView(a.buffer,f,p);return this[A][o]=l.call(Ht,h)}}function oe(t,e={}){const{isChildActive:n=q,isChildMutable:s=q}=e,{instance:{members:o}}=t,i=o.filter(r=>r.structure.hasPointer);return function(c,l={}){var d;const{source:a,vivificate:u=!1,isActive:f=q,isMutable:p=q}=l,h={...l,isActive:y=>f(this)&&n.call(this,y),isMutable:y=>p(this)&&s.call(this,y)};for(const{slot:y}of i){if(a){const g=(d=a[A])==null?void 0:d[y];if(!g)continue;h.source=g}const m=this[A][y]??(u?this[W](y):null);m&&m[D](c,h)}}}function eo(t,e){const{type:n,constructor:s,static:{members:o,template:i}}=t,r={};for(const c of o)r[c.name]=C(c,e);if(F(s,{valueOf:{value:L},toJSON:{value:G},...r,[Symbol.iterator]:{value:Ze},[A]:i&&{value:i[A]},[lt]:!s[lt]&&{value:o.map(c=>c.name)},[k]:{value:Ye}}),n===x.Enumeration)for(const{name:c,slot:l}of o)Ge(s,c,s[A][l]);else if(n===x.ErrorSet)for(const{name:c,slot:l}of o)Fs(s,c,s[A][l])}function no(t,e){const{byteSize:n,align:s,instance:{members:o},hasPointer:i}=t,r=!!o.find(h=>h.type===T.Object),c=t.constructor=function(h){const d=e.allocateMemory(n,s);this[b]=d,r&&(this[A]={}),u.call(this,h)},l=o.slice(0,-1).map(h=>h.name),a=l.length,u=function(h){if(h.length!==a)throw new vn(t,h.length);for(const[d,y]of l.entries())try{this[y]=h[d]}catch(m){throw Pn(t,d,m)}},f={};for(const h of o)f[h.name]=C(h,e);const p=function(h){return h===this.retval};return F(c.prototype,{...f,[$]:{value:B(n)},[W]:r&&{value:se(t)},[D]:i&&{value:oe(t,{isChildMutable:p})}}),F(c,{[j]:{value:s},[N]:{value:n}}),c}function so(t,e){const{length:n,byteSize:s,align:o,instance:{members:[i]},hasPointer:r}=t,{get:c,set:l}=C(i,e),a=en(i),u=et(t),f=function(w){if(w instanceof h)this[$](w),r&&this[D](Ot,{vivificate:!0,source:w});else if(typeof w=="string"&&a&&(w={string:w}),w!=null&&w[Symbol.iterator]){if(w=cn(w),w.length!==n)throw new Pt(t,this,w);let O=0;for(const P of w)l.call(this,O++,P)}else if(w&&typeof w=="object"){if(u.call(this,w)===0)throw new rt(t,w)}else if(w!==void 0)throw new rt(t,w)},p=Qe,h=t.constructor=X(t,{initializer:f,finalizer:p},e),d=t.typedArray=ut(i),y=i.type===T.Object,m={$:{get:ne,set:f},length:{value:n},dataView:nt(t),base64:st(t),string:a&&_e(t),typedArray:d&&pt(t),get:{value:c},set:{value:l},entries:{value:ie},valueOf:{value:L},toJSON:{value:G},delete:{value:Q(e)},[Symbol.iterator]:{value:sn},[$]:{value:B(s)},[W]:y&&{value:on(t)},[D]:r&&{value:rn()},[k]:{value:nn},[z]:{value:tn}},g={child:{get:()=>i.structure.constructor},[xt]:{value:Nt(t)},[j]:{value:o},[N]:{value:s}};return H(h,m,g)}function Qe(){const t=new Proxy(this,io);return Object.defineProperty(this,Ft,{value:t}),t}function tn(){ft.call(this),Object.defineProperty(this,"set",{value:dt});const t=this.get;Object.defineProperty(this,"get",{value:function(n){var o;const s=t.call(this,n);return(s==null?void 0:s[at])===null&&((o=s[z])==null||o.call(s)),s}})}function en(t){return t.type===T.Uint&&[8,16].includes(t.bitSize)}function nn(t,e){const n=[];for(const[s,o]of ie.call(this,e))n.push(t(o));return n}function sn(){const t=this[Kt]??this,e=this.length;let n=0;return{next(){let s,o;if(n<e){const i=n++;s=t.get(i),o=!1}else o=!0;return{value:s,done:o}}}}function oo(t){const e=this[Kt]??this,n=this.length;let s=0;return{next(){let o,i;if(s<n){const r=s++;o=[r,ee(()=>e.get(r),t)],i=!1}else i=!0;return{value:o,done:i}}}}function ie(t){return{[Symbol.iterator]:oo.bind(this,t),length:this.length}}function on(t){const{instance:{members:[e]}}=t,{byteSize:n,structure:s}=e;return function(i){const{constructor:r}=s,c=this[b],a=c.byteOffset+n*i,u=new DataView(c.buffer,a,n);return this[A][i]=r.call(Ht,u)}}function rn(t){return function(n,s={}){const{source:o,vivificate:i=!1,isActive:r=q,isMutable:c=q}=s,l={...s,isActive:()=>r(this),isMutable:()=>c(this)};for(let a=0,u=this.length;a<u;a++){o&&(l.source=o==null?void 0:o[A][a]);const f=this[A][a]??(i?this[W](a):null);f&&f[D](n,l)}}}function cn(t){var o;if(typeof t.length=="number")return t;const e=t[Symbol.iterator](),n=e.next(),s=(o=n.value)==null?void 0:o.length;if(typeof s=="number"&&Object.keys(n.value).join()==="length")return Object.assign(function*(){let i;for(;!(i=e.next()).done;)yield i.value}(),{length:s});{const i=[];let r=n;for(;!r.done;)i.push(r.value),r=e.next();return i}}const io={get(t,e){const n=typeof e=="symbol"?0:e|0;if(n!==0||n==e)return t.get(n);switch(e){case"get":return t[mt]||(t[mt]=t.get.bind(t)),t[mt];case"set":return t[bt]||(t[bt]=t.set.bind(t)),t[bt];case Kt:return t;default:return t[e]}},set(t,e,n){const s=typeof e=="symbol"?0:e|0;if(s!==0||s==e)t.set(s,n);else switch(e){case"get":t[mt]=n;break;case"set":t[bt]=n;break;default:t[e]=n}return!0},deleteProperty(t,e){const n=typeof e=="symbol"?0:e|0;if(n!==0||n==e)return!1;switch(e){case"get":delete t[mt];break;case"set":delete t[bt];break;default:delete t[e]}return!0},has(t,e){const n=typeof e=="symbol"?0:e|0;return n!==0||n==e?n>=0&&n<t.length:t[e]},ownKeys(t){const e=[];for(let n=0,s=t.length;n<s;n++)e.push(`${n}`);return e.push("length",Ft),e},getOwnPropertyDescriptor(t,e){const n=typeof e=="symbol"?0:e|0;if(n!==0||n==e){if(n>=0&&n<t.length)return{value:t.get(n),enumerable:!0,writable:!0,configurable:!0}}else return Object.getOwnPropertyDescriptor(t,e)}};function ro(t,e){const{byteSize:n,align:s,instance:{members:o},hasPointer:i}=t,{get:r,set:c}=C(o[0],e),{get:l,set:a}=C(o[1],e),u=function(){if(l.call(this,"number"))throw l.call(this);return r.call(this)},f=o[0].type===T.Void,p=o[1].structure.constructor,h=function(){return!l.call(this,"number")},d=function(){var E;this[pe](),(E=this[D])==null||E.call(this,qs)},y=!!o.find(E=>E.type===T.Object),m=et(t),g=function(E){if(E instanceof w)this[$](E),i&&h.call(this)&&this[D](Ot,{vivificate:!0,source:E});else if(E instanceof p[gt]&&p(E))a.call(this,E),d.call(this);else if(E!==void 0||f)try{c.call(this,E),a.call(this,0,"number")}catch(R){if(E instanceof Error)throw new xe(t);if(vt(E))a.call(this,E),d.call(this);else if(E&&typeof E=="object"){if(m.call(this,E)===0)throw R}else throw R}},w=t.constructor=X(t,{initializer:g},e),{bitOffset:O,byteSize:P}=o[0],M={$:{get:u,set:g},dataView:nt(t),base64:st(t),valueOf:{value:L},toJSON:{value:G},delete:{value:Q(e)},[$]:{value:B(n)},[pe]:{value:Wn(O/8,P)},[W]:y&&{value:se(t)},[D]:i&&{value:oe(t,{isChildActive:h})},[k]:{value:Re},[z]:{value:ft}},v={[j]:{value:s},[N]:{value:n}};return H(w,M,v)}function co(t,e){const{byteSize:n,align:s,instance:{members:[o]}}=t,{get:i,set:r}=C(o,e),c=et(t),l=function(h){if(h instanceof a)this[$](h);else if(h&&typeof h=="object"){if(c.call(this,h)===0){const d=Te(o);throw new ct(t,d,h)}}else h!==void 0&&r.call(this,h)},a=t.constructor=X(t,{initializer:l},e),u=t.typedArray=ut(o),f={$:{get:i,set:r},dataView:nt(t),base64:st(t),typedArray:u&&pt(t),valueOf:{value:L},toJSON:{value:G},delete:{value:Q(e)},[Symbol.toPrimitive]:{value:i},[$]:{value:B(n)},[k]:{value:Re},[z]:{value:ft}},p={[xt]:{value:Nt(t)},[j]:{value:s},[N]:{value:n}};return H(a,f,p)}function lo(t,e){const{align:n,instance:{members:[s]},hasPointer:o}=t,{get:i,set:r}=C(s,e),{byteSize:c,structure:l}=s,a=uo(t,e);a&&(t.sentinel=a);const u=en(s),f=function(v,E,R=!1){v||(v=e.allocateMemory(E*c,n,R)),this[b]=v,this[Jt]=E},p=function(v,E){if(E!==this[Jt])throw new Pt(t,this,v)},h=et(t),d=function(v,E=!1){if(v instanceof m)this[b]?p.call(this,v,v.length):f.call(this,null,v.length,E),this[$](v),o&&this[D](Ot,{vivificate:!0,source:v});else if(typeof v=="string"&&u)d.call(this,{string:v},E);else if(v!=null&&v[Symbol.iterator]){v=cn(v),this[b]?p.call(this,v,v.length):f.call(this,null,v.length,E);let R=0;for(const ot of v)a==null||a.validateValue(ot,R,v.length),r.call(this,R++,ot)}else if(typeof v=="number")if(!this[b]&&v>=0&&isFinite(v))f.call(this,null,v);else throw new rt(t,v,!this[b]);else if(v&&typeof v=="object"){if(h.call(this,v,E)===0)throw new rt(t,v)}else if(v!==void 0)throw new rt(t,v)},y=Qe,m=t.constructor=X(t,{initializer:d,shapeDefiner:f,finalizer:y},e),g=t.typedArray=ut(s),w=s.type===T.Object,O={shapeDefiner:f},P={$:{get:ne,set:d},length:{get:ao},dataView:nt(t,O),base64:st(t,O),string:u&&_e(t,O),typedArray:g&&pt(t,O),get:{value:i},set:{value:r},entries:{value:ie},valueOf:{value:L},toJSON:{value:G},delete:{value:Q(e)},[Symbol.iterator]:{value:sn},[$]:{value:B(c,!0)},[W]:w&&{value:on(t)},[D]:o&&{value:rn()},[k]:{value:nn},[z]:{value:tn}},M={child:{get:()=>l.constructor},[xt]:{value:Nt(t)},[j]:{value:n},[N]:{value:c}};return H(m,P,M)}function ao(){return this[Jt]}function uo(t,e){const{runtimeSafety:n=!0}=e,{byteSize:s,instance:{members:[o,i],template:r}}=t;if(!i)return;const{get:c}=C(i,e),l=c.call(r,0),{get:a}=C(o,e),u=n?function(h,d,y){if(h===l&&d!==y-1)throw new ae(t,h,d,y);if(h!==l&&d===y-1)throw new It(t,l,d,y)}:function(h,d,y){if(h!==l&&d===y-1)throw new It(t,l,y)},f=n?function(h,d){for(let y=0;y<d;y++){const m=a.call(h,y);if(m===l&&y!==d-1)throw new ae(t,l,y,d);if(m!==l&&y===d-1)throw new It(t,l,d)}}:function(h,d){if(d*s===h[b].byteLength){const y=d-1;if(a.call(h,y)!==l)throw new It(t,l,d)}},p=r[b];return{value:l,bytes:p,validateValue:u,validateData:f}}const U=Array(Object.values(x).length);function Vo(){U[x.Primitive]=co}function Mo(){U[x.Array]=so}function $o(){U[x.Struct]=Qs}function Po(){U[x.ArgStruct]=no}function Do(){U[x.ErrorUnion]=ro}function jo(){U[x.ErrorSet]=We,ms()}function Co(){U[x.Enumeration]=Ls,ps()}function Fo(){U[x.Pointer]=Rs,ds()}function zo(){U[x.Slice]=lo}function No(){U[x.Vector]=Ks}function fo(t){return U[t]}class ho{constructor(){V(this,"context");V(this,"contextStack",[]);V(this,"consolePending",[]);V(this,"consoleTimeout",0);V(this,"viewMap",new WeakMap);V(this,"initPromise");V(this,"abandoned",!1);V(this,"released",!1);V(this,"littleEndian",!0);V(this,"runtimeSafety",!0);V(this,"comptime",!1);V(this,"variables",[]);V(this,"imports");V(this,"console",globalThis.console)}startContext(){this.context&&this.contextStack.push(this.context),this.context=new yo}endContext(){this.context=this.contextStack.pop()}allocateMemory(e,n=0,s=!1){return s?this.allocateFixedMemory(e,n):this.allocateRelocMemory(e,n)}allocateRelocMemory(e,n){return this.obtainView(new ArrayBuffer(e),0,e)}registerMemory(e,n=null,s=void 0){const{memoryList:o}=this.context,i=this.getViewAddress(e),r=Rt(o,i);return o.splice(r,0,{address:i,dv:e,len:e.byteLength,targetDV:n,targetAlign:s}),i}unregisterMemory(e){const{memoryList:n}=this.context,s=Rt(n,e),o=n[s-1];(o==null?void 0:o.address)===e&&n.splice(s-1,1)}findMemory(e,n,s){if(bo(e))if(!n)e=0;else return null;let o=n*(s??0);if(this.context){const{memoryList:i}=this.context,r=Rt(i,e),c=i[r-1];if((c==null?void 0:c.address)===e&&c.len===o)return c.targetDV??c.dv;if((c==null?void 0:c.address)<=e&&e<ht(c.address,c.len)){const l=Number(e-c.address),a=c.targetDV??c.dv,u=s===void 0;u&&(o=a.byteLength-l);const f=this.obtainView(a.buffer,a.byteOffset+l,o);return u&&(f[j]=c.targetAlign),f}}return this.obtainFixedView(e,o)}getViewAddress(e){const n=this.getBufferAddress(e.buffer);return ht(n,e.byteOffset)}obtainView(e,n,s){let o=this.viewMap.get(e);if(!o){const c=new DataView(e,n,s);return this.viewMap.set(e,c),c}if(o instanceof DataView){if(o.byteOffset===n&&o.byteLength===s)return o;{const c=o;o={[`${c.byteOffset}:${c.byteLength}`]:c},this.viewMap.set(e,o)}}const i=`${n}:${s}`;let r=o[i];return r||(r=o[i]=new DataView(e,n,s)),r}captureView(e,n,s){if(s){const o=this.allocateRelocMemory(n,0);return n>0&&this.copyBytes(o,e,n),o}else return this.obtainFixedView(e,n)}castView(e,n,s){var c;const{constructor:o,hasPointer:i}=e,r=o.call(wt,n);return i&&this.acquirePointerTargets(r),s||(c=r[z])==null||c.call(r),r}finalizeShape(e){const s=fo(e.type)(e,this);typeof s=="function"&&(F(s,{name:{value:e.name,configurable:!0}}),s.prototype.hasOwnProperty(Symbol.toStringTag)||F(s.prototype,{[Symbol.toStringTag]:{value:e.name,configurable:!0}}))}finalizeStructure(e){eo(e,this),ks(e,this)}createCaller(e,n){const{name:s,argStruct:o,thunkId:i}=e,{constructor:r}=o,c=this;let l;return n?l=function(...a){return c.invokeThunk(i,new r([this,...a]))}:l=function(...a){return c.invokeThunk(i,new r(a))},Object.defineProperty(l,"name",{value:s}),l}recreateStructures(e,n){Object.assign(this,n);const s=(r,c)=>{for(const[l,a]of Object.entries(c))r[l]=o(a);return r},o=r=>{var c;if(r.memory){const{array:l,offset:a,length:u}=r.memory,f=this.obtainView(l.buffer,a,u),{constructor:p}=r.structure,{reloc:h,const:d}=r,y=p.call(wt,f);return d&&((c=y[z])==null||c.call(y)),r.slots&&s(y[A],r.slots),h!==void 0&&this.variables.push({reloc:h,object:y}),y}else return r.structure};zs();const i=new Map;for(const r of e){for(const c of[r.instance,r.static])if(c.template){const l=c.template,a=c.template={};if(l.memory){const{array:u,offset:f,length:p}=l.memory;a[b]=this.obtainView(u.buffer,f,p)}if(l.slots){const u=a[A]={};i.set(u,l.slots)}}this.finalizeShape(r)}for(const[r,c]of i)s(r,c);for(const r of e)this.finalizeStructure(r)}linkVariables(e){const n=[];for(const{object:s,reloc:o}of this.variables)this.linkObject(s,o,e),s[it]&&s[A][0]&&n.push(s);for(const s of n){const o=s[it](),i=this.getViewAddress(o[b]),{length:r=1}=o;s[yt]={address:i,length:r}}}linkObject(e,n,s){if(this.inFixedMemory(e))return;const o=e[b],i=this.recreateAddress(n),r=this.obtainFixedView(i,o.byteLength);if(s){const l=Object.create(e.constructor.prototype);l[b]=r,l[$](e)}e[b]=r;const c=l=>{if(l[A]){for(const a of Object.values(l[A]))if(a){const u=a[b];if(u.buffer===o.buffer){const f=u.byteOffset-o.byteOffset;a[b]=this.obtainView(r.buffer,f,u.byteLength),c(a)}}}};c(e)}unlinkVariables(){for(const{object:e}of this.variables)this.unlinkObject(e)}unlinkObject(e){if(!this.inFixedMemory(e))return;const n=e[b],s=this.allocateMemory(n.byteLength),o=Object.create(e.constructor.prototype);o[b]=s,o[$](e),e[b]=s}releaseFunctions(){const e=()=>{throw new Error("Module was abandoned")};for(const n of Object.keys(this.imports))this[n]&&(this[n]=e)}getSpecialExports(){return{init:()=>this.initPromise??Promise.resolve(),abandon:()=>this.abandon(),released:()=>this.released,connect:e=>this.console=e}}abandon(){this.abandoned||(this.releaseFunctions(),this.unlinkVariables(),this.abandoned=!0)}writeToConsole(e){const{console:n}=this;try{const s=new Uint8Array(e.buffer,e.byteOffset,e.byteLength).slice(),o=s.lastIndexOf(10);if(o===-1)this.consolePending.push(s);else{const i=s.subarray(0,o),r=s.subarray(o+1),c=[...this.consolePending,i];n.log(St(c)),this.consolePending=r.length>0?[r]:[]}clearTimeout(this.consoleTimeout),this.consolePending.length>0&&(this.consoleTimeout=setTimeout(()=>{n.log(St(this.consolePending)),this.consolePending=[]},250))}catch(s){n.error(s)}}flushConsole(){this.consolePending.length>0&&(console.log(St(this.consolePending)),this.consolePending=[],clearTimeout(this.consoleTimeout))}updatePointerAddresses(e){const n=new Map,s=new Map,o=[],i=this,r=function({isActive:a}){var p;if(!a(this))return;const u=this[Tt];if(n.get(u))return;const f=u[A][0];if(f&&(n.set(u,f),!i.inFixedMemory(f))){const h=f[b],d=s.get(h.buffer);if(d){const y=Array.isArray(d)?d:[d],m=ln(y,h.byteOffset,g=>g[b].byteOffset);y.splice(m,0,f),Array.isArray(d)||(s.set(h.buffer,y),o.push(y))}else s.set(h.buffer,f);(p=f[D])==null||p.call(f,r)}};e[D](r);const c=this.findTargetClusters(o),l=new Map;for(const a of c)for(const u of a.targets)l.set(u,a);for(const[a,u]of n){const f=l.get(u),{length:p=1}=u;let h=this.getTargetAddress(u,f);h===!1&&(h=this.getShadowAddress(u,f)),a[Ve]({address:h,length:p})}}findTargetClusters(e){const n=[];for(const s of e){let o=null,i=0,r=0,c=null;for(const l of s){const a=l[b],{byteOffset:u,byteLength:f}=a,p=u+f;let h=!0;o&&(r>u?(c||(c={targets:[o],start:i,end:r,address:void 0,misaligned:void 0},n.push(c)),c.targets.push(l),p>r?c.end=p:h=!1):c=null),h&&(o=l,i=u,r=p)}}return n}createClusterShadow(e){const{start:n,end:s,targets:o}=e;let i=0,r;for(const g of o){const w=g[b],O=w.byteOffset,P=g.constructor[j]??w[j];(i===void 0||P>i)&&(i=P,r=O)}const c=s-n,l=this.allocateShadowMemory(c+i,1),a=this.getViewAddress(l),u=mo(ht(a,r-n),i),f=ht(u,n-r),p=l.byteOffset+Number(f-a),h=new DataView(l.buffer,p,c);for(const g of o){const w=g[b],O=w.byteOffset;if(O!==r){const P=g.constructor[j]??w[j];if(po(ht(f,O-n),P))throw new xn(P,i)}}const d={[$]:B(c)},y=Object.create(d),m=Object.create(d);return y[b]=new DataView(o[0][b].buffer,Number(n),c),m[b]=h,m[Vt]={address:a,len:l.byteLength,align:1},this.addShadow(m,y,1)}getShadowAddress(e,n){if(n){const s=e[b];if(n.address===void 0){const o=this.createClusterShadow(n);n.address=this.getViewAddress(o[b])}return ht(n.address,s.byteOffset-n.start)}else{const s=this.createShadow(e);return this.getViewAddress(s[b])}}createShadow(e){const n=e[b],s=e.constructor[j]??n[j],o=Object.create(e.constructor.prototype),i=o[b]=this.allocateShadowMemory(n.byteLength,s);return o[Vt]={address:this.getViewAddress(i),len:i.byteLength,align:s},this.addShadow(o,e,s)}addShadow(e,n,s){let{shadowMap:o}=this.context;return o||(o=this.context.shadowMap=new Map),o.set(e,n),this.registerMemory(e[b],n[b],s),e}removeShadow(e){const{shadowMap:n}=this.context;if(n){for(const[s]of n)if(s[b]===e){n.delete(s);break}}}updateShadows(){const{shadowMap:e}=this.context;if(e)for(const[n,s]of e)n[$](s)}updateShadowTargets(){const{shadowMap:e}=this.context;if(e)for(const[n,s]of e)s[$](n)}releaseShadows(){const{shadowMap:e}=this.context;if(e)for(const[n]of e){const{address:s,len:o,align:i}=n[Vt];this.freeShadowMemory(s,o,i)}}acquirePointerTargets(e){const n=this,s=new Map,o=function({isActive:i,isMutable:r}){var p,h;const c=this[Tt];if(s.get(c))return;s.set(c,!0);const l=!c.constructor.const,a=c[A][0];let u,f;if(i(this)){const d=c.constructor.child;if(!a||r(this)){f=c[Wt]();const y=n.findMemory(f.address,f.length,d[N]);u=y?d.call(wt,y):null}else u=a}(p=a==null?void 0:a[D])==null||p.call(a,o,{vivificate:!0,isMutable:()=>l}),u!==a&&((h=u==null?void 0:u[D])==null||h.call(u,o,{vivificate:!0,isMutable:()=>l}),c[A][0]=u,n.inFixedMemory(c)&&(c[yt]=f))};e[D](o,{vivificate:!0})}}class yo{constructor(){V(this,"pointerProcessed",new Map);V(this,"memoryList",[]);V(this,"shadowMap",null);V(this,"call",0)}}function ln(t,e,n){let s=0,o=t.length;if(o===0)return 0;for(;s<o;){const i=Math.floor((s+o)/2);n(t[i])<=e?s=i+1:o=i}return o}function Rt(t,e){return ln(t,e,n=>n.address)}function po(t,e){if(e===void 0)return!1;typeof t=="bigint"&&(t=Number(t&0xFFFFFFFFn));const n=e-1;return(t&n)!==0}function mo(t,e){let n;return typeof t=="bigint"?(e=BigInt(e),n=~(e-1n)):n=~(e-1),(t&n)+e}function ht(t,e){return t+(typeof t=="bigint"?BigInt(e):e)}function bo(t){return typeof t=="bigint"?t===0xaaaaaaaaaaaaaaaan:t===2863311530}class go extends ho{constructor(){super(...arguments);V(this,"imports",{getFactoryThunk:{argType:"",returnType:"i"},allocateExternMemory:{argType:"ii",returnType:"i"},freeExternMemory:{argType:"iii"},allocateShadowMemory:{argType:"cii",returnType:"v"},freeShadowMemory:{argType:"ciii"},runThunk:{argType:"iv",returnType:"v"},isRuntimeSafetyActive:{argType:"",returnType:"b"}});V(this,"exports",{allocateHostMemory:{argType:"ii",returnType:"v"},freeHostMemory:{argType:"iii"},captureString:{argType:"ii",returnType:"v"},captureView:{argType:"iib",returnType:"v"},castView:{argType:"vvb",returnType:"v"},getSlotNumber:{argType:"ii",returnType:"i"},readSlot:{argType:"vi",returnType:"v"},writeSlot:{argType:"viv"},getViewAddress:{argType:"v",returnType:"i"},beginDefinition:{returnType:"v"},insertInteger:{argType:"vsi",alias:"insertProperty"},insertBoolean:{argType:"vsb",alias:"insertProperty"},insertString:{argType:"vss",alias:"insertProperty"},insertObject:{argType:"vsv",alias:"insertProperty"},beginStructure:{argType:"v",returnType:"v"},attachMember:{argType:"vvb"},attachMethod:{argType:"vvb"},createTemplate:{argType:"v",returnType:"v"},attachTemplate:{argType:"vvb"},finalizeShape:{argType:"v"},endStructure:{argType:"v"},startCall:{argType:"iv",returnType:"i"},endCall:{argType:"iv",returnType:"i"}});V(this,"nextValueIndex",1);V(this,"valueTable",{0:null});V(this,"valueIndices",new Map);V(this,"memory",null);V(this,"littleEndian",!0)}allocateHostMemory(n,s){const o={[j]:s},i=B(n),r=this.allocateRelocMemory(n,s),c=this.allocateShadowMemory(n,s),l={constructor:o,[b]:r,[$]:i},a={constructor:o,[b]:c,[$]:i};return a[Vt]={address:this.getViewAddress(c),len:n,align:s},this.addShadow(a,l,s),c}freeHostMemory(n,s,o){const i=this.findMemory(n,s,1);this.removeShadow(i),this.unregisterMemory(n),this.freeShadowMemory(n,s,o)}getBufferAddress(n){return 0}allocateFixedMemory(n,s){const o=n?this.allocateExternMemory(n,s):0,i=this.obtainFixedView(o,n);return i[j]=s,i}freeFixedMemory(n,s,o){s&&this.freeExternMemory(n,s,o)}obtainFixedView(n,s){const{memory:o}=this,i=this.obtainView(o.buffer,n,s);return i[b]={memory:o,address:n,len:s},i}releaseFixedView(n){n.buffer;const s=n.byteOffset,o=n.byteLength,i=n[j];i!==void 0&&this.freeFixedMemory(s,o,i)}inFixedMemory(n){return this.memory?(_.call(n),n[b].buffer===this.memory.buffer):!1}copyBytes(n,s,o){const{memory:i}=this,r=new DataView(i.buffer,s,o);Pe(o)(n,r)}findSentinel(n,s){const{memory:o}=this,i=s.byteLength,r=o.buffer.byteLength-i+1;for(let c=n;c<r;c+=i){const l=new DataView(o.buffer,c,i);let a=!0;for(let u=0;u<i;u++){const f=l.getUint8(u),p=s.getUint8(u);if(f!==p){a=!1;break}}if(a)return(c-n)/i}}captureString(n,s){const{buffer:o}=this.memory,i=new Uint8Array(o,n,s);return St(i)}getTargetAddress(n,s){return this.inFixedMemory(n)?this.getViewAddress(n[b]):n[b].byteLength===0?0:!1}clearExchangeTable(){this.nextValueIndex!==1&&(this.nextValueIndex=1,this.valueTable={0:null},this.valueIndices=new Map)}getObjectIndex(n){if(n){let s=this.valueIndices.get(n);return s===void 0&&(s=this.nextValueIndex++,this.valueIndices.set(n,s),this.valueTable[s]=n),s}else return 0}fromWebAssembly(n,s){switch(n){case"v":case"s":return this.valueTable[s];case"i":return s;case"b":return!!s}}toWebAssembly(n,s){switch(n){case"v":case"s":return this.getObjectIndex(s);case"i":return s;case"b":return s?1:0}}exportFunction(n,s="",o=""){return n?(...i)=>{i=i.map((c,l)=>this.fromWebAssembly(s.charAt(l),c));const r=n.apply(this,i);return this.toWebAssembly(o,r)}:()=>{}}importFunction(n,s="",o=""){let i=!1;return s.startsWith("c")&&(i=!0,s=s.slice(1)),(...r)=>{r=r.map((l,a)=>this.toWebAssembly(s.charAt(a),l)),i&&(r=[this.context.call,...r]);const c=n.apply(this,r);return this.fromWebAssembly(o,c)}}exportFunctions(){const n={};for(const[s,{argType:o,returnType:i,alias:r}]of Object.entries(this.exports)){const c=this[r??s];n[`_${s}`]=this.exportFunction(c,o,i)}return n}importFunctions(n){for(const[s,o]of Object.entries(n)){const i=this.imports[s];if(i){const{argType:r,returnType:c}=i;this[s]=this.importFunction(o,r,c)}}}async instantiateWebAssembly(n){const s=await n,o=this.exportFunctions(),i=this.getWASI(),r={env:o,wasi_snapshot_preview1:i};return s[Symbol.toStringTag]==="Response"?WebAssembly.instantiateStreaming(s,r):WebAssembly.instantiate(s,r)}loadModule(n){return this.initPromise=(async()=>{const{instance:s}=await this.instantiateWebAssembly(n),{memory:o,_initialize:i}=s.exports;this.importFunctions(s.exports),this.trackInstance(s),this.runtimeSafety=this.isRuntimeSafetyActive(),this.memory=o,i==null||i()})()}trackInstance(n){const s=new WeakRef(n);Object.defineProperty(this,"released",{get:()=>!s.deref(),enumerable:!0})}linkVariables(n){this.initPromise&&(this.initPromise=this.initPromise.then(()=>super.linkVariables(n)))}getMemoryOffset(n){return n}recreateAddress(n){return n}startCall(n,s){this.startContext(),this.context.call=n,s[D]&&this.updatePointerAddresses(s);const o=this.getShadowAddress(s);return this.updateShadows(),o}endCall(n,s){this.updateShadowTargets(),s[D]&&this.acquirePointerTargets(s),this.releaseShadows(),this.endContext(),!this.context&&this.flushConsole&&this.flushConsole()}async runThunk(n,s){return await this.initPromise,this.runThunk(n,s)}invokeThunk(n,s){const o=this.runThunk(n,s);if(o){if(o[Symbol.toStringTag]==="Promise")return o.then(i=>{if(i)throw new he(i);return s.retval});throw new he(o)}return s.retval}getWASI(){return{fd_write:(n,s,o,i)=>{if(n===1||n===2){const r=new DataView(this.memory.buffer);let c=0;for(let l=0,a=s;l<o;l++,a+=8){const u=r.getUint32(a,!0),f=r.getUint32(a+4,!0),p=new DataView(this.memory.buffer,u,f);this.writeToConsole(p),c+=f}return r.setUint32(i,c,!0),0}else return 1},random_get:(n,s)=>{const o=new DataView(this.memory.buffer,n,s);for(let i=0;i<s;i++)o.setUint8(i,Math.floor(256*Math.random()));return 0},proc_exit:()=>{},path_open:()=>1,fd_read:()=>1,fd_close:()=>1}}}function ko(t){return new go}export{Mo as a,Fo as b,$o as c,No as d,zo as e,Co as f,jo as g,Do as h,Po as i,ko as j,Eo as k,ds as l,xo as m,Oo as n,To as o,Ao as p,So as q,vo as r,Vo as u};
